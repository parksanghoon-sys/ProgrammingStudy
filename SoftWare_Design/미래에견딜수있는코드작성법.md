# 미래에 견딜 수 있는 .NET 코드를 작성하는 방법

[보통
](https://medium.com/@ravikumar.makwana/how-to-write-future-proof-net-code-039186300196)

---

## 한 줄 요약

**미래 지향적인 .NET 코드는 “변화를 전제로 한 설계”에서 나온다.**

---

## 핵심 요점 6가지

### 1️⃣ 구현이 아니라 **계약(Interface)** 중심으로 설계

* 프레임워크·라이브러리에 직접 의존하지 말 것
* 인터페이스만 안정적으로 유지하면 구현 교체는 쉬움
* EF, SendGrid, Azure SDK 같은 것들과 느슨하게 결합

👉  **원칙** : concrete 클래스가 아니라 abstraction에 의존

---

### 2️⃣ 하드코딩 금지, **구성(Configuration) 기반 설계**

* URL, 제한값, 플래그 등은 전부 config로 분리
* `IOptions<T>` 패턴 적극 활용
* 배포 없이 동작 변경 가능 (Feature Flag, Azure App Config)

👉  **원칙** : 코드 수정이 아니라 설정 변경으로 대응

---

### 3️⃣ 상속보다 **컴포지션(Composition)**

* 깊은 상속 구조는 유지보수 지옥
* 필요한 기능은 주입해서 조립
* 로깅, 알림, 정책 등은 교체 가능하게

👉  **원칙** : 상속 ❌ / 의존성 주입 ⭕

---

### 4️⃣ `Microsoft.Extensions.*` 추상화 적극 사용

* DI, Logging, Configuration, Hosting은 장기적으로 매우 안정적
* .NET Core 2.x → .NET 9까지 거의 동일
* Minimal API, Worker, MAUI로 이동해도 구조 유지

👉  **원칙** : 커스텀 부트스트랩보다 공식 추상화 사용

---

### 5️⃣ **도메인 로직을 순수하게 유지**

* 도메인은 C# POCO 객체만
* EF Core, Controller, DB 로직 섞지 말 것
* 인프라 교체해도 비즈니스 로직은 그대로

👉  **원칙** : 도메인은 프레임워크를 몰라야 한다

---

### 6️⃣ **테스트 가능성과 관측성(Observability)** 고려

* 테스트가 쉬운 코드는 리팩토링도 쉬움
* static, DateTime.Now 직접 사용 ❌
* `TimeProvider`(.NET 8+)로 시간 제어
* 로깅·메트릭·트레이싱 필수

👉  **원칙** : 테스트 + 로그는 미래 업그레이드의 안전망

---

## 최종 결론

미래 지향 코드는 **다음 .NET 버전을 예측하는 것**이 아니라
**변화를 자연스럽게 받아들이는 구조**를 만드는 것이다.

✔ 인터페이스 중심
✔ 구성 분리
✔ 컴포지션
✔ 안정적인 추상화
✔ 순수한 도메인
✔ 테스트 & 관측성
