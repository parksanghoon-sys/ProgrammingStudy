
소프트웨어 결합도(Coupling)의 종류별 구체적인 예시를 코드로 설명드리겠습니다.

## 결합도의 종류와 예시 (강한 결합도 → 약한 결합도 순)

### 1. 내용 결합도 (Content Coupling) - 최악

**한 모듈이 다른 모듈의 내부를 직접 조작하는 경우**

```java
class BankAccount {
    public double balance = 1000.0;  // public으로 노출
    private String accountNumber;
}

class TransactionProcessor {
    public void processWithdraw(BankAccount account, double amount) {
        // 다른 클래스의 내부 데이터를 직접 수정 (매우 위험!)
        account.balance -= amount;  
        if (account.balance < 0) {
            account.balance = 0;  // 직접 조작
        }
    }
}
```

### 2. 공통 결합도 (Common Coupling) - 매우 나쁨

**전역 변수를 여러 모듈이 공유하는 경우**

```java
// 전역 설정 클래스
class GlobalConfig {
    public static String databaseUrl = "localhost:3306";
    public static int maxConnections = 10;
    public static boolean debugMode = false;
}

class DatabaseManager {
    public void connect() {
        // 전역 변수에 직접 의존
        System.out.println("Connecting to: " + GlobalConfig.databaseUrl);
        GlobalConfig.maxConnections--;  // 전역 상태 변경
    }
}

class Logger {
    public void log(String message) {
        // 다른 모듈도 같은 전역 변수 사용
        if (GlobalConfig.debugMode) {
            System.out.println("[DEBUG] " + message);
        }
    }
}
```

### 3. 외부 결합도 (External Coupling) - 나쁨

**외부 형식이나 프로토콜을 여러 모듈이 공유하는 경우**

```java
// 외부 API의 특정 형식에 강하게 의존
class PaymentProcessor {
    public void processPayment(String xmlData) {
        // 특정 XML 형식에 강하게 결합
        // <payment><amount>100</amount><currency>USD</currency></payment>
        String amount = extractXmlValue(xmlData, "amount");
        String currency = extractXmlValue(xmlData, "currency");
    }
}

class OrderManager {
    public void createOrder() {
        // 같은 XML 형식을 생성해야 함
        String paymentXml = "<payment><amount>100</amount><currency>USD</currency></payment>";
        PaymentProcessor processor = new PaymentProcessor();
        processor.processPayment(paymentXml);
    }
}
```

### 4. 제어 결합도 (Control Coupling) - 나쁨

**플래그나 제어 정보를 전달하여 다른 모듈의 동작을 제어하는 경우**

```java
class ReportGenerator {
    // 플래그로 다른 모듈의 동작을 제어
    public void generateReport(int reportType, boolean includeCharts, boolean sendEmail) {
        if (reportType == 1) {
            generateSalesReport();
        } else if (reportType == 2) {
            generateInventoryReport();
        }
      
        if (includeCharts) {
            addChartsToReport();
        }
      
        if (sendEmail) {
            emailReport();  // 다른 기능까지 제어
        }
    }
}

class ReportController {
    public void createMonthlyReport() {
        ReportGenerator generator = new ReportGenerator();
        // 다른 모듈의 내부 동작을 제어
        generator.generateReport(1, true, false);
    }
}
```

### 5. 스탬프 결합도 (Stamp Coupling) - 보통

**복합 데이터 구조를 전달하지만 일부만 사용하는 경우**

```java
class Employee {
    private String name;
    private String address;
    private double salary;
    private String department;
    private Date hireDate;
    // ... 많은 필드들
}

class PayrollCalculator {
    // Employee 전체 객체를 받지만 salary만 사용
    public double calculateTax(Employee employee) {
        return employee.getSalary() * 0.2;  // salary만 사용
    }
}

class EmailService {
    // Employee 전체 객체를 받지만 name, address만 사용
    public void sendWelcomeEmail(Employee employee) {
        String message = "Welcome " + employee.getName() + 
                        " to address: " + employee.getAddress();
        // name과 address만 실제로 사용
    }
}
```

### 6. 자료 결합도 (Data Coupling) - 좋음

**필요한 단순 데이터만 전달하는 경우**

```java
class MathUtils {
    // 필요한 데이터만 매개변수로 전달
    public double calculateArea(double length, double width) {
        return length * width;
    }
  
    public double calculateCircumference(double radius) {
        return 2 * Math.PI * radius;
    }
}

class ShapeCalculator {
    public void calculateRectangle() {
        MathUtils math = new MathUtils();
        // 필요한 값만 전달
        double area = math.calculateArea(10.0, 5.0);
        double circumference = math.calculateCircumference(3.0);
    }
}
```

### 7. 메시지 결합도 (Message Coupling) - 최선

**상태 없는 메시지나 이벤트만 전달하는 경우**

```java
// 인터페이스 기반 통신
interface EventListener {
    void onEvent();
}

class Button {
    private List<EventListener> listeners = new ArrayList<>();
  
    public void addClickListener(EventListener listener) {
        listeners.add(listener);
    }
  
    public void click() {
        // 상태 없는 메시지만 전달
        for (EventListener listener : listeners) {
            listener.onEvent();
        }
    }
}

class Dialog implements EventListener {
    @Override
    public void onEvent() {
        // 매개변수 없는 메시지 수신
        this.close();
    }
}
```

## 결합도를 낮추는 개선 예시

### Before: 강한 결합도

```java
class OrderProcessor {
    public void processOrder(Order order) {
        // 구체적인 클래스에 직접 의존 (강한 결합)
        MySQLDatabase db = new MySQLDatabase();
        EmailService email = new EmailService();
        SmsService sms = new SmsService();
      
        db.save(order);
        email.sendConfirmation(order.getCustomerEmail());
        sms.sendNotification(order.getCustomerPhone());
    }
}
```

### After: 약한 결합도

```java
// 인터페이스로 추상화
interface Database {
    void save(Order order);
}

interface NotificationService {
    void sendNotification(String recipient, String message);
}

class OrderProcessor {
    private Database database;
    private NotificationService emailService;
    private NotificationService smsService;
  
    // 의존성 주입으로 결합도 감소
    public OrderProcessor(Database database, 
                         NotificationService emailService,
                         NotificationService smsService) {
        this.database = database;
        this.emailService = emailService;
        this.smsService = smsService;
    }
  
    public void processOrder(Order order) {
        database.save(order);
        emailService.sendNotification(order.getCustomerEmail(), "Order confirmed");
        smsService.sendNotification(order.getCustomerPhone(), "Order confirmed");
    }
}
```

## 결합도 개선 기법

 **의존성 역전** : 구체적인 구현이 아닌 추상화에 의존하게 만듭니다.

 **의존성 주입** : 객체가 직접 의존 객체를 생성하지 않고 외부에서 주입받습니다.

 **이벤트 기반 아키텍처** : 직접 호출 대신 이벤트를 통해 통신합니다.

 **인터페이스 분리** : 클라이언트가 사용하지 않는 인터페이스에 의존하지 않게 합니다.

낮은 결합도는 모듈의 독립성을 높여 유지보수성, 테스트 용이성, 재사용성을 크게 향상시킵니다.
