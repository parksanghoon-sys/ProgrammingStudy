# 응집도

소프트웨어 응집도(Cohesion)의 종류별 구체적인 예시를 설명드리겠습니다.

## 응집도의 종류와 예시 (낮은 응집도 → 높은 응집도 순)

### 1. 우연적 응집도 (Coincidental Cohesion) - 최악

**관련 없는 기능들이 하나의 모듈에 모여있는 경우**

```java
class Utilities {
    public void printReport() { /* 보고서 출력 */ }
    public int calculateTax() { /* 세금 계산 */ }
    public void sendEmail() { /* 이메일 발송 */ }
    public String formatDate() { /* 날짜 포맷 */ }
}
```

### 2. 논리적 응집도 (Logical Cohesion) - 나쁨

**비슷한 성격의 기능들이 모여있지만 실행 시점이나 조건이 다른 경우**

```java
class InputHandler {
    public void handleInput(int type, Object data) {
        switch(type) {
            case 1: readFromKeyboard(); break;
            case 2: readFromFile(); break;
            case 3: readFromDatabase(); break;
            case 4: readFromNetwork(); break;
        }
    }
}
```

### 3. 시간적 응집도 (Temporal Cohesion) - 나쁨

**특정 시점에 실행되어야 하는 기능들이 모여있는 경우**

```java
class SystemInitializer {
    public void initialize() {
        initializeDatabase();
        setupLogging();
        loadConfiguration();
        startNetworkService();
        createTempFiles();
    }
}
```

### 4. 절차적 응집도 (Procedural Cohesion) - 보통

**순서대로 실행되는 기능들이 모여있는 경우 (다른 데이터 사용)**

```java
class FileProcessor {
    public void processFile(String filename) {
        openFile(filename);
        readHeader();
        validateData();
        updateDatabase();
        generateReport();
        closeFile();
    }
}
```

### 5. 통신적 응집도 (Communicational Cohesion) - 보통

**같은 데이터를 다루는 기능들이 모여있는 경우**

```java
class StudentRecord {
    private Student student;
  
    public void updateStudentInfo() { /* 학생 정보 업데이트 */ }
    public void printStudentTranscript() { /* 성적표 출력 */ }
    public void calculateStudentGPA() { /* GPA 계산 */ }
}
```

### 6. 순차적 응집도 (Sequential Cohesion) - 좋음

**한 기능의 출력이 다음 기능의 입력이 되는 경우**

```java
class DataProcessor {
    public String processData(String rawData) {
        String cleaned = cleanData(rawData);
        String validated = validateData(cleaned);
        String transformed = transformData(validated);
        return transformed;
    }
  
    private String cleanData(String data) { /* */ }
    private String validateData(String data) { /* */ }
    private String transformData(String data) { /* */ }
}
```

### 7. 기능적 응집도 (Functional Cohesion) - 최선

**하나의 명확한 기능만 수행하는 경우**

```java
// 좋은 예시들
class Calculator {
    public double add(double a, double b) {
        return a + b;
    }
}

class EmailValidator {
    public boolean isValid(String email) {
        return email.matches("^[A-Za-z0-9+_.-]+@(.+)$");
    }
}

class PriceCalculator {
    public double calculateTotalPrice(List<Item> items, double taxRate) {
        double subtotal = items.stream()
            .mapToDouble(Item::getPrice)
            .sum();
        return subtotal * (1 + taxRate);
    }
}
```

## 실제 프로젝트에서의 예시

### 낮은 응집도 (피해야 할 예시)

```java
class OrderManager {
    public void processOrder() { /* 주문 처리 */ }
    public void sendSMS() { /* SMS 발송 */ }
    public void validateCreditCard() { /* 신용카드 검증 */ }
    public void updateInventory() { /* 재고 업데이트 */ }
    public void generateInvoice() { /* 송장 생성 */ }
    public void logSystemEvent() { /* 시스템 로그 */ }
}
```

### 높은 응집도 (권장하는 예시)

```java
// 각각이 명확한 단일 책임을 가짐
class Order {
    public void process() { /* 주문만 처리 */ }
}

class NotificationService {
    public void sendSMS(String message) { /* SMS만 발송 */ }
}

class PaymentValidator {
    public boolean validateCreditCard(String cardNumber) { /* 신용카드만 검증 */ }
}

class InventoryManager {
    public void updateStock(String productId, int quantity) { /* 재고만 관리 */ }
}
```

## 높은 응집도의 장점

 **유지보수성** : 기능이 명확해서 수정이 쉬움
 **재사용성** : 독립적인 기능으로 다른 곳에서도 사용 가능

 **테스트 용이성** : 단일 기능이라 테스트 시나리오가 명확
 **이해도** : 코드의 목적과 동작을 쉽게 파악 가능

높은 응집도를 달성하려면 **단일 책임 원칙(Single Responsibility Principle)**을 따라 각 클래스나 메소드가 하나의 명확한 목적만 가지도록 설계하는 것이 중요합니다.
