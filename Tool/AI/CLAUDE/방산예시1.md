ì¢‹ì•„ìš”! ì‹¤ì „ì—ì„œ ë°”ë¡œ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ìˆ˜ì¤€ìœ¼ë¡œ ê° íŒŒì¼ì˜ ìƒì„¸í•œ ë‚´ìš©ì„ ë³´ì—¬ë“œë¦¬ê² ìŠµë‹ˆë‹¤.

# ğŸ“ ìƒì„¸ íŒŒì¼ ë‚´ìš© ì˜ˆì‹œ

## 1. ğŸ¯ Skills ìƒì„¸

### .claude/skills/defense-standards/SKILL.md

```markdown
---
name: defense-standards-compliance
description: ë°©ì‚° í‘œì¤€(MIL-STD-498, DO-178C) ì¤€ìˆ˜ ì „ë¬¸ê°€
---

# Defense Standards Compliance Skill

## ì—­í• 
ë°©ì‚° ì†Œí”„íŠ¸ì›¨ì–´ ê°œë°œ í‘œì¤€ì„ ì¤€ìˆ˜í•˜ëŠ” ì½”ë“œì™€ ë¬¸ì„œë¥¼ ì‘ì„±í•©ë‹ˆë‹¤.

## MIL-STD-498 í•„ìˆ˜ ì‚°ì¶œë¬¼

### 1. Software Requirements Specification (SRS)
ëª¨ë“  ê¸°ëŠ¥ êµ¬í˜„ ì‹œ SRS ì—…ë°ì´íŠ¸ í•„ìš”

```markdown
## ìš”êµ¬ì‚¬í•­ ID: REQ-TCS-001
**ì œëª©**: ì‹¤ì‹œê°„ í‘œì  ì¶”ì  ê¸°ëŠ¥
**ìš°ì„ ìˆœìœ„**: Critical
**ì¶œì²˜**: ì‘ì „ìš”êµ¬ì„œ ORD-2024-001
**ë³´ì•ˆë“±ê¸‰**: ëŒ€ì™¸ë¹„

### ê¸°ëŠ¥ ìš”êµ¬ì‚¬í•­
ì‹œìŠ¤í…œì€ ë‹¤ìŒ ì¡°ê±´ì„ ë§Œì¡±í•´ì•¼ í•œë‹¤:
1. ìµœëŒ€ 500ê°œì˜ í‘œì ì„ ë™ì‹œ ì¶”ì 
2. í‘œì  ìœ„ì¹˜ ì—…ë°ì´íŠ¸ ì£¼ê¸°: 100ms ì´í•˜
3. í‘œì  ì •ë³´ ì •í™•ë„: ìœ„ì¹˜ì˜¤ì°¨ Â±10m ì´ë‚´

### ì„±ëŠ¥ ìš”êµ¬ì‚¬í•­
- ì‘ë‹µì‹œê°„: 50ms ì´ë‚´
- CPU ì‚¬ìš©ë¥ : í‰ê·  40% ì´í•˜
- ë©”ëª¨ë¦¬: ìµœëŒ€ 2GB

### ë³´ì•ˆ ìš”êµ¬ì‚¬í•­
- ëª¨ë“  í‘œì  ë°ì´í„°ëŠ” AES-256ìœ¼ë¡œ ì•”í˜¸í™”
- ì ‘ê·¼ ê¶Œí•œ: TACTICAL_OPERATOR ì´ìƒ
- ëª¨ë“  ì¡°íšŒ ì‘ì—… ê°ì‚¬ ë¡œê·¸ ê¸°ë¡

### í…ŒìŠ¤íŠ¸ ê¸°ì¤€
- ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ ì»¤ë²„ë¦¬ì§€: 90% ì´ìƒ
- í†µí•© í…ŒìŠ¤íŠ¸: ëª¨ë“  ì‹œë‚˜ë¦¬ì˜¤ í†µê³¼
- ì„±ëŠ¥ í…ŒìŠ¤íŠ¸: 500ê°œ í‘œì  ë™ì‹œ ì²˜ë¦¬ ê°€ëŠ¥
```

### 2. ì½”ë“œ ì‘ì„± ì‹œ í•„ìˆ˜ ì£¼ì„

```csharp
/// <summary>
/// [REQ-TCS-001] ì‹¤ì‹œê°„ í‘œì  ì¶”ì  ì„œë¹„ìŠ¤
/// </summary>
/// <remarks>
/// <para>í‘œì¤€ ì¤€ìˆ˜: MIL-STD-498 SRS Section 3.2</para>
/// <para>ë³´ì•ˆë“±ê¸‰: ëŒ€ì™¸ë¹„</para>
/// <para>ì‘ì„±ì¼: 2024-02-11</para>
/// <para>ì‘ì„±ì: [ê°œë°œìëª…]</para>
/// <para>ê²€í† ì: [ê²€í† ìëª…]</para>
/// </remarks>
public class TargetTrackingService : ITargetTrackingService
{
    /// <summary>
    /// [REQ-TCS-001.1] í‘œì  ìœ„ì¹˜ë¥¼ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤.
    /// </summary>
    /// <param name="targetId">í‘œì  ì‹ë³„ì</param>
    /// <param name="position">ìƒˆë¡œìš´ ìœ„ì¹˜ ì •ë³´</param>
    /// <returns>ì—…ë°ì´íŠ¸ ì„±ê³µ ì—¬ë¶€</returns>
    /// <exception cref="SecurityException">ê¶Œí•œì´ ì—†ëŠ” ê²½ìš°</exception>
    /// <exception cref="TargetNotFoundException">í‘œì ì„ ì°¾ì„ ìˆ˜ ì—†ëŠ” ê²½ìš°</exception>
    /// <remarks>
    /// ì„±ëŠ¥ ìš”êµ¬ì‚¬í•­: 50ms ì´ë‚´ ì²˜ë¦¬
    /// ë³´ì•ˆ: ê¶Œí•œ ì²´í¬ í•„ìˆ˜, ê°ì‚¬ ë¡œê·¸ ê¸°ë¡
    /// </remarks>
    public async Task<UpdateResult> UpdateTargetPositionAsync(
        string targetId, 
        GeoPosition position)
    {
        // [REQ-TCS-001.1.1] ê¶Œí•œ ì²´í¬
        await _securityService.EnsurePermissionAsync("UPDATE_TARGET");
      
        // [REQ-TCS-001.1.2] ì…ë ¥ ê²€ì¦
        if (!IsValidPosition(position))
            throw new InvalidPositionException();
      
        // [REQ-TCS-001.1.3] ê°ì‚¬ ë¡œê·¸
        _auditLogger.Log(AuditEvent.TargetPositionUpdate, 
            new { targetId, position, user = _currentUser });
      
        // [REQ-TCS-001.1.4] ì—…ë°ì´íŠ¸ ìˆ˜í–‰
        var result = await _repository.UpdateAsync(targetId, position);
      
        return result;
    }
}
```

### 3. DO-178C ì•ˆì „ì„± ë ˆë²¨ë³„ ì²˜ë¦¬

```csharp
/// <summary>
/// [DO-178C Level A] ì¹˜ëª…ì  ê¸°ëŠ¥ - ê°€ì¥ ì—„ê²©í•œ í…ŒìŠ¤íŠ¸ í•„ìš”
/// ì‹œìŠ¤í…œ ì˜¤ë¥˜ ì‹œ ì¸ëª… í”¼í•´ ê°€ëŠ¥
/// </summary>
public class WeaponControlSystem
{
    // Level A: 100% êµ¬ì¡°ì  ì»¤ë²„ë¦¬ì§€ í•„ìš”
    // Level A: Modified Condition/Decision Coverage (MC/DC) í•„ìš”
}

/// <summary>
/// [DO-178C Level B] ìœ„í—˜ ê¸°ëŠ¥ - ì—„ê²©í•œ í…ŒìŠ¤íŠ¸ í•„ìš”
/// ì‹œìŠ¤í…œ ì˜¤ë¥˜ ì‹œ ì„ë¬´ ì‹¤íŒ¨ ê°€ëŠ¥
/// </summary>
public class NavigationSystem
{
    // Level B: Decision Coverage í•„ìš”
}

/// <summary>
/// [DO-178C Level D] ì¼ë°˜ ê¸°ëŠ¥ - ê¸°ë³¸ í…ŒìŠ¤íŠ¸
/// ì‹œìŠ¤í…œ ì˜¤ë¥˜ ì‹œ ì˜í–¥ ë¯¸ë¯¸
/// </summary>
public class LoggingService
{
    // Level D: Statement Coverage í•„ìš”
}
```

## ì½”ë”© í‘œì¤€ ì²´í¬ë¦¬ìŠ¤íŠ¸

### í•„ìˆ˜ ì‚¬í•­ âœ…

```csharp
// 1. ëª¨ë“  public ë©¤ë²„ì— XML ì£¼ì„
/// <summary>...</summary>
public class MyClass { }

// 2. ëª¨ë“  ë©”ì„œë“œì— ì˜ˆì™¸ ë¬¸ì„œí™”
/// <exception cref="ArgumentNullException">ë§¤ê°œë³€ìˆ˜ê°€ nullì¸ ê²½ìš°</exception>

// 3. ë§¤ì§ ë„˜ë²„ ê¸ˆì§€ - ìƒìˆ˜ ì‚¬ìš©
// âŒ ë‚˜ìœ ì˜ˆ
if (count > 500) { }

// âœ… ì¢‹ì€ ì˜ˆ
private const int MAX_TARGET_COUNT = 500;
if (count > MAX_TARGET_COUNT) { }

// 4. í•˜ë“œì½”ë”©ëœ ë¬¸ìì—´ ê¸ˆì§€ - ë¦¬ì†ŒìŠ¤ ì‚¬ìš©
// âŒ ë‚˜ìœ ì˜ˆ
throw new Exception("Error occurred");

// âœ… ì¢‹ì€ ì˜ˆ
throw new Exception(Resources.ErrorMessages.GeneralError);

// 5. íŒŒì¼ í—¤ë” í•„ìˆ˜
/*
 * íŒŒì¼ëª…: TargetTrackingService.cs
 * í”„ë¡œì íŠ¸: TacticalCommandSystem
 * ì‘ì„±ì: [ì´ë¦„]
 * ì‘ì„±ì¼: 2024-02-11
 * ë³´ì•ˆë“±ê¸‰: ëŒ€ì™¸ë¹„
 * ì„¤ëª…: ì‹¤ì‹œê°„ í‘œì  ì¶”ì  ì„œë¹„ìŠ¤ êµ¬í˜„
 * ìš”êµ¬ì‚¬í•­: REQ-TCS-001
 * í‘œì¤€: MIL-STD-498
 */
```

## ë³€ê²½ ì´ë ¥ ê´€ë¦¬

```csharp
/// <summary>
/// í‘œì  ì¶”ì  ì„œë¹„ìŠ¤
/// </summary>
/// <history>
/// <change date="2024-02-11" author="í™ê¸¸ë™" version="1.0.0">
///   ìµœì´ˆ ì‘ì„±
/// </change>
/// <change date="2024-02-15" author="ê¹€ì² ìˆ˜" version="1.1.0">
///   [REQ-TCS-002] ë‹¤ì¤‘ ì„¼ì„œ í†µí•© ê¸°ëŠ¥ ì¶”ê°€
/// </change>
/// <change date="2024-02-20" author="ì´ì˜í¬" version="1.1.1">
///   ì„±ëŠ¥ ìµœì í™” - ì‘ë‹µì‹œê°„ 30% ê°œì„ 
/// </change>
/// </history>
public class TargetTrackingService : ITargetTrackingService
{
    // êµ¬í˜„...
}
```

## í…ŒìŠ¤íŠ¸ í‘œì¤€

```csharp
/// <summary>
/// [REQ-TCS-001] í‘œì  ì¶”ì  ì„œë¹„ìŠ¤ í…ŒìŠ¤íŠ¸
/// </summary>
/// <remarks>
/// í…ŒìŠ¤íŠ¸ ë ˆë²¨: Unit Test
/// ì»¤ë²„ë¦¬ì§€ ëª©í‘œ: 90%
/// í‘œì¤€: MIL-STD-498 STP
/// </remarks>
[TestClass]
public class TargetTrackingServiceTests
{
    /// <summary>
    /// [TEST-TCS-001-001] ì •ìƒì ì¸ ìœ„ì¹˜ ì—…ë°ì´íŠ¸ í…ŒìŠ¤íŠ¸
    /// </summary>
    /// <remarks>
    /// ì „ì œì¡°ê±´:
    /// - ìœ íš¨í•œ í‘œì  ID ì¡´ì¬
    /// - ì‚¬ìš©ì ê¶Œí•œ ìˆìŒ
    /// 
    /// í…ŒìŠ¤íŠ¸ ë‹¨ê³„:
    /// 1. í‘œì  ìœ„ì¹˜ ì—…ë°ì´íŠ¸ ìš”ì²­
    /// 2. ê²°ê³¼ í™•ì¸
    /// 
    /// ì˜ˆìƒ ê²°ê³¼:
    /// - ì—…ë°ì´íŠ¸ ì„±ê³µ
    /// - ê°ì‚¬ ë¡œê·¸ ê¸°ë¡ë¨
    /// - 50ms ì´ë‚´ ì‘ë‹µ
    /// </remarks>
    [TestMethod]
    [TestCategory("Positive")]
    [TestCategory("Performance")]
    [Timeout(100)] // 100ms ì´ë‚´ ì™„ë£Œ
    public async Task UpdateTargetPosition_ValidInput_Success()
    {
        // Arrange
        var service = CreateService();
        var targetId = "TGT-001";
        var position = new GeoPosition(37.5665, 126.9780);
      
        // Act
        var stopwatch = Stopwatch.StartNew();
        var result = await service.UpdateTargetPositionAsync(targetId, position);
        stopwatch.Stop();
      
        // Assert
        Assert.IsTrue(result.IsSuccess);
        Assert.IsTrue(stopwatch.ElapsedMilliseconds < 50, 
            "ì‘ë‹µì‹œê°„ ìš”êµ¬ì‚¬í•­ ìœ„ë°˜");
        _auditLoggerMock.Verify(x => 
            x.Log(AuditEvent.TargetPositionUpdate, It.IsAny<object>()), 
            Times.Once, "ê°ì‚¬ ë¡œê·¸ ëˆ„ë½");
    }
  
    /// <summary>
    /// [TEST-TCS-001-002] ê¶Œí•œ ì—†ëŠ” ì‚¬ìš©ì ì ‘ê·¼ ì°¨ë‹¨ í…ŒìŠ¤íŠ¸
    /// </summary>
    [TestMethod]
    [TestCategory("Negative")]
    [TestCategory("Security")]
    [ExpectedException(typeof(SecurityException))]
    public async Task UpdateTargetPosition_NoPermission_ThrowsException()
    {
        // Arrange
        var service = CreateServiceWithoutPermission();
      
        // Act
        await service.UpdateTargetPositionAsync("TGT-001", 
            new GeoPosition(37.5665, 126.9780));
      
        // AssertëŠ” ExpectedExceptionìœ¼ë¡œ ì²˜ë¦¬
    }
}
```

## ì„±ëŠ¥ ë²¤ì¹˜ë§ˆí¬ í‘œì¤€

```csharp
[MemoryDiagnoser]
[SimpleJob(RuntimeMoniker.Net60)]
public class TargetTrackingBenchmarks
{
    /// <summary>
    /// [PERF-TCS-001] 500ê°œ í‘œì  ë™ì‹œ ì¶”ì  ì„±ëŠ¥ í…ŒìŠ¤íŠ¸
    /// ìš”êµ¬ì‚¬í•­: 100ms ì´ë‚´ ì²˜ë¦¬
    /// </summary>
    [Benchmark]
    [Arguments(500)]
    public async Task Track_500_Targets(int targetCount)
    {
        var service = CreateService();
        var targets = GenerateTargets(targetCount);
      
        foreach (var target in targets)
        {
            await service.UpdateTargetPositionAsync(
                target.Id, target.Position);
        }
    }
}
```

## ì°¸ê³  ë¬¸ì„œ

* MIL-STD-498: @docs/standards/mil-std-498/
* DO-178C: @docs/standards/do-178c/
* ì½”ë”© ì»¨ë²¤ì…˜: @docs/standards/coding-convention.md
* í…ŒìŠ¤íŠ¸ ì „ëµ: @docs/testing/test-strategy.md

```

---

### .claude/skills/real-time-systems/SKILL.md

```markdown
---
name: real-time-systems-expert
description: ì‹¤ì‹œê°„ ì‹œìŠ¤í…œ ì„¤ê³„ ë° ì„±ëŠ¥ ìµœì í™” ì „ë¬¸ê°€
---

# Real-Time Systems Expert Skill

## ì—­í• 
ë°©ì‚° ì‹œìŠ¤í…œì˜ ì‹¤ì‹œê°„ ì„±ëŠ¥ ìš”êµ¬ì‚¬í•­ì„ ë§Œì¡±í•˜ëŠ” ì½”ë“œë¥¼ ì‘ì„±í•©ë‹ˆë‹¤.

## ì‹¤ì‹œê°„ ì²˜ë¦¬ íŒ¨í„´

### 1. ê³ ì • ì£¼ê¸° íƒœìŠ¤í¬ (Fixed-Rate Task)

```csharp
/// <summary>
/// 100ms ì£¼ê¸°ë¡œ ì„¼ì„œ ë°ì´í„°ë¥¼ ì½ëŠ” ì‹¤ì‹œê°„ íƒœìŠ¤í¬
/// </summary>
public class SensorPollingTask : IRealtimeTask
{
    private readonly PeriodicTimer _timer;
    private readonly TimeSpan _period = TimeSpan.FromMilliseconds(100);
    private readonly ILogger<SensorPollingTask> _logger;
    private readonly PerformanceCounter _jitterCounter;
  
    public SensorPollingTask(ILogger<SensorPollingTask> logger)
    {
        _logger = logger;
        _timer = new PeriodicTimer(_period);
        _jitterCounter = new PerformanceCounter();
    }
  
    public async Task RunAsync(CancellationToken cancellationToken)
    {
        // ìš°ì„ ìˆœìœ„ ì„¤ì • (ì‹¤ì‹œê°„ ìš°ì„ ìˆœìœ„)
        Thread.CurrentThread.Priority = ThreadPriority.Highest;
      
        var expectedTime = DateTime.UtcNow;
      
        while (await _timer.WaitForNextTickAsync(cancellationToken))
        {
            var startTime = DateTime.UtcNow;
          
            try
            {
                // Jitter ì¸¡ì •
                var jitter = (startTime - expectedTime).TotalMilliseconds;
                _jitterCounter.Record(jitter);
              
                if (Math.Abs(jitter) > 10) // 10ms ì´ìƒ ì§€ì—° ì‹œ ê²½ê³ 
                {
                    _logger.LogWarning(
                        "Timing jitter detected: {Jitter}ms", jitter);
                }
              
                // ì‹¤ì œ ì‘ì—… ìˆ˜í–‰
                await ProcessSensorDataAsync(cancellationToken);
              
                // ì‹¤í–‰ ì‹œê°„ ì¸¡ì •
                var executionTime = (DateTime.UtcNow - startTime).TotalMilliseconds;
              
                if (executionTime > 50) // ì£¼ê¸°ì˜ 50% ì´ˆê³¼ ì‹œ ê²½ê³ 
                {
                    _logger.LogWarning(
                        "Execution time exceeded budget: {Time}ms", 
                        executionTime);
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Sensor polling task failed");
                // ì‹¤ì‹œê°„ íƒœìŠ¤í¬ëŠ” ì˜ˆì™¸ë¡œ ì¤‘ë‹¨ë˜ë©´ ì•ˆ ë¨
            }
          
            expectedTime = expectedTime.Add(_period);
        }
    }
  
    private async Task ProcessSensorDataAsync(CancellationToken cancellationToken)
    {
        // ì„¼ì„œ ë°ì´í„° ì²˜ë¦¬
        // ì£¼ì˜: ì´ ë©”ì„œë“œëŠ” ë°˜ë“œì‹œ 50ms ì´ë‚´ì— ì™„ë£Œë˜ì–´ì•¼ í•¨
    }
}
```

### 2. Lock-Free ë°ì´í„° êµ¬ì¡°

```csharp
/// <summary>
/// Lock-Free ë§ ë²„í¼ (ì‹¤ì‹œê°„ ì„±ëŠ¥ ë³´ì¥)
/// </summary>
/// <typeparam name="T">ì €ì¥í•  ë°ì´í„° íƒ€ì…</typeparam>
public class LockFreeRingBuffer<T>
{
    private readonly T[] _buffer;
    private readonly int _capacity;
    private int _head;
    private int _tail;
  
    public LockFreeRingBuffer(int capacity)
    {
        _capacity = capacity;
        _buffer = new T[capacity];
        _head = 0;
        _tail = 0;
    }
  
    /// <summary>
    /// Lock-Free Enqueue (Wait-Free ë³´ì¥)
    /// </summary>
    public bool TryEnqueue(T item)
    {
        int currentTail;
        int nextTail;
      
        do
        {
            currentTail = _tail;
            nextTail = (currentTail + 1) % _capacity;
          
            // ë²„í¼ê°€ ê°€ë“ ì°¼ëŠ”ì§€ í™•ì¸
            if (nextTail == Volatile.Read(ref _head))
                return false;
              
        } while (Interlocked.CompareExchange(
            ref _tail, nextTail, currentTail) != currentTail);
      
        _buffer[currentTail] = item;
        return true;
    }
  
    /// <summary>
    /// Lock-Free Dequeue
    /// </summary>
    public bool TryDequeue(out T item)
    {
        int currentHead;
        int nextHead;
      
        do
        {
            currentHead = _head;
          
            // ë²„í¼ê°€ ë¹„ì—ˆëŠ”ì§€ í™•ì¸
            if (currentHead == Volatile.Read(ref _tail))
            {
                item = default;
                return false;
            }
          
            nextHead = (currentHead + 1) % _capacity;
          
        } while (Interlocked.CompareExchange(
            ref _head, nextHead, currentHead) != currentHead);
      
        item = _buffer[currentHead];
        return true;
    }
}
```

### 3. ì‹¤ì‹œê°„ ë©”ëª¨ë¦¬ ê´€ë¦¬

```csharp
/// <summary>
/// ê°ì²´ í’€ - GC ì••ë ¥ ìµœì†Œí™”
/// </summary>
public class ObjectPool<T> where T : class, new()
{
    private readonly ConcurrentBag<T> _pool = new();
    private readonly int _maxSize;
    private int _currentSize;
  
    public ObjectPool(int maxSize = 100)
    {
        _maxSize = maxSize;
      
        // í’€ ë¯¸ë¦¬ ì±„ìš°ê¸° (ì´ˆê¸°í™” ì‹œ GC ë°œìƒ)
        for (int i = 0; i < maxSize / 2; i++)
        {
            _pool.Add(new T());
            _currentSize++;
        }
    }
  
    public T Rent()
    {
        if (_pool.TryTake(out var obj))
        {
            Interlocked.Decrement(ref _currentSize);
            return obj;
        }
      
        // í’€ì´ ë¹„ì–´ìˆìœ¼ë©´ ìƒˆë¡œ ìƒì„± (GC ì••ë ¥)
        return new T();
    }
  
    public void Return(T obj)
    {
        if (_currentSize < _maxSize)
        {
            // ì¬ì‚¬ìš©ì„ ìœ„í•´ ë¦¬ì…‹
            if (obj is IResettable resettable)
                resettable.Reset();
          
            _pool.Add(obj);
            Interlocked.Increment(ref _currentSize);
        }
        // else: í’€ì´ ê°€ë“ ì°¨ë©´ GCì— ë§¡ê¹€
    }
}

// ì‚¬ìš© ì˜ˆì‹œ
public class SensorDataProcessor
{
    private readonly ObjectPool<SensorDataBuffer> _bufferPool;
  
    public async Task ProcessAsync(CancellationToken ct)
    {
        // GC ë°œìƒ ì—†ì´ ë²„í¼ ì¬ì‚¬ìš©
        var buffer = _bufferPool.Rent();
        try
        {
            await ReadSensorDataAsync(buffer, ct);
            ProcessData(buffer);
        }
        finally
        {
            _bufferPool.Return(buffer);
        }
    }
}
```

### 4. ìš°ì„ ìˆœìœ„ ê¸°ë°˜ ìŠ¤ì¼€ì¤„ë§

```csharp
/// <summary>
/// ì‹¤ì‹œê°„ íƒœìŠ¤í¬ ìŠ¤ì¼€ì¤„ëŸ¬
/// Rate Monotonic Scheduling (RMS) ì•Œê³ ë¦¬ì¦˜ ì‚¬ìš©
/// </summary>
public class RealtimeTaskScheduler
{
    private readonly PriorityQueue<IRealtimeTask, int> _taskQueue;
    private readonly SemaphoreSlim _semaphore;
  
    public RealtimeTaskScheduler()
    {
        _taskQueue = new PriorityQueue<IRealtimeTask, int>();
        _semaphore = new SemaphoreSlim(0);
    }
  
    /// <summary>
    /// íƒœìŠ¤í¬ ë“±ë¡ (ì£¼ê¸°ê°€ ì§§ì„ìˆ˜ë¡ ë†’ì€ ìš°ì„ ìˆœìœ„)
    /// </summary>
    public void RegisterTask(IRealtimeTask task, TimeSpan period)
    {
        // ìš°ì„ ìˆœìœ„ = ì£¼ê¸°ì˜ ì—­ìˆ˜ (ì£¼ê¸°ê°€ ì§§ìœ¼ë©´ ìš°ì„ ìˆœìœ„ ë†’ìŒ)
        int priority = (int)(1000000 / period.TotalMicroseconds);
      
        _taskQueue.Enqueue(task, priority);
      
        // CPU ì¹œí™”ì„± ì„¤ì • (íŠ¹ì • ì½”ì–´ì— ê³ ì •)
        var thread = new Thread(() => RunTask(task))
        {
            Priority = ThreadPriority.Highest,
            IsBackground = false // Foreground ìŠ¤ë ˆë“œë¡œ ì‹¤í–‰
        };
      
        // ì½”ì–´ 0ì— ê³ ì • (ì‹¤ì‹œê°„ ì²˜ë¦¬ ì „ìš©)
        SetThreadAffinityMask(thread, 0x01);
      
        thread.Start();
    }
  
    private void RunTask(IRealtimeTask task)
    {
        // ì‹¤ì‹œê°„ ìš°ì„ ìˆœìœ„ ì„¤ì •
        var handle = GetCurrentThread();
        SetThreadPriority(handle, THREAD_PRIORITY_TIME_CRITICAL);
      
        var cts = new CancellationTokenSource();
        task.RunAsync(cts.Token).GetAwaiter().GetResult();
    }
  
    [DllImport("kernel32.dll")]
    private static extern IntPtr GetCurrentThread();
  
    [DllImport("kernel32.dll")]
    private static extern bool SetThreadPriority(IntPtr hThread, int nPriority);
  
    private const int THREAD_PRIORITY_TIME_CRITICAL = 15;
}
```

### 5. ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§

```csharp
/// <summary>
/// ì‹¤ì‹œê°„ ì„±ëŠ¥ ëª¨ë‹ˆí„°
/// </summary>
public class RealtimePerformanceMonitor
{
    private readonly Dictionary<string, PerformanceMetrics> _metrics = new();
    private readonly object _lock = new();
  
    public IDisposable Measure(string operationName, 
        TimeSpan maxAllowedTime)
    {
        return new PerformanceMeasurement(
            operationName, maxAllowedTime, this);
    }
  
    private class PerformanceMeasurement : IDisposable
    {
        private readonly string _operationName;
        private readonly TimeSpan _maxAllowedTime;
        private readonly RealtimePerformanceMonitor _monitor;
        private readonly Stopwatch _stopwatch;
      
        public PerformanceMeasurement(
            string operationName,
            TimeSpan maxAllowedTime,
            RealtimePerformanceMonitor monitor)
        {
            _operationName = operationName;
            _maxAllowedTime = maxAllowedTime;
            _monitor = monitor;
            _stopwatch = Stopwatch.StartNew();
        }
      
        public void Dispose()
        {
            _stopwatch.Stop();
            var elapsed = _stopwatch.Elapsed;
          
            _monitor.RecordMeasurement(_operationName, elapsed);
          
            if (elapsed > _maxAllowedTime)
            {
                // ì‹¤ì‹œê°„ ìš”êµ¬ì‚¬í•­ ìœ„ë°˜!
                throw new RealtimeViolationException(
                    $"{_operationName} exceeded time budget: " +
                    $"{elapsed.TotalMilliseconds}ms > " +
                    $"{_maxAllowedTime.TotalMilliseconds}ms");
            }
        }
    }
  
    private void RecordMeasurement(string operationName, TimeSpan elapsed)
    {
        lock (_lock)
        {
            if (!_metrics.ContainsKey(operationName))
                _metrics[operationName] = new PerformanceMetrics();
          
            _metrics[operationName].Record(elapsed);
        }
    }
  
    public RealtimeReport GenerateReport()
    {
        lock (_lock)
        {
            return new RealtimeReport(_metrics);
        }
    }
}

// ì‚¬ìš© ì˜ˆì‹œ
public async Task ProcessCriticalData()
{
    using (_perfMonitor.Measure("ProcessCriticalData", 
        TimeSpan.FromMilliseconds(50)))
    {
        // ì´ ë¸”ë¡ì€ 50ms ì´ë‚´ì— ì™„ë£Œë˜ì–´ì•¼ í•¨
        // ì´ˆê³¼ ì‹œ RealtimeViolationException ë°œìƒ
        await DoWork();
    }
}
```

## ì‹¤ì‹œê°„ ì‹œìŠ¤í…œ ì²´í¬ë¦¬ìŠ¤íŠ¸

### ì„¤ê³„ ë‹¨ê³„

* [ ] ìµœì•… ì‹¤í–‰ ì‹œê°„ (WCET) ë¶„ì„
* [ ] ìš°ì„ ìˆœìœ„ ì—­ì „ ë°©ì§€ ì „ëµ
* [ ] ë°ë“œë½ ë°©ì§€ ì„¤ê³„
* [ ] íƒ€ì´ë° ë¶„ì„ (RMS/EDF)

### êµ¬í˜„ ë‹¨ê³„

* [ ] GC ì••ë ¥ ìµœì†Œí™” (ê°ì²´ í’€, êµ¬ì¡°ì²´ í™œìš©)
* [ ] Lock-Free ì•Œê³ ë¦¬ì¦˜ ì‚¬ìš©
* [ ] CPU ì¹œí™”ì„± ì„¤ì •
* [ ] ì‹¤ì‹œê°„ ìš°ì„ ìˆœìœ„ ì„¤ì •

### í…ŒìŠ¤íŠ¸ ë‹¨ê³„

* [ ] ìµœëŒ€ ì§€ì—° ì‹œê°„ (Latency) ì¸¡ì •
* [ ] Jitter ì¸¡ì • ë° í—ˆìš© ë²”ìœ„ í™•ì¸
* [ ] ë¶€í•˜ í…ŒìŠ¤íŠ¸ (ìµœì•…ì˜ ê²½ìš°)
* [ ] ì¥ì‹œê°„ ì•ˆì •ì„± í…ŒìŠ¤íŠ¸

## ê¸ˆì§€ ì‚¬í•­

```csharp
// âŒ ì‹¤ì‹œê°„ ê²½ë¡œì—ì„œ ì ˆëŒ€ ê¸ˆì§€
public async Task RealtimeMethod()
{
    // 1. Thread.Sleep ê¸ˆì§€
    Thread.Sleep(100);
  
    // 2. lock ë¬¸ ê¸ˆì§€ (Lock-Free ì‚¬ìš©)
    lock (_lockObject) { }
  
    // 3. LINQ ê¸ˆì§€ (í• ë‹¹ ë°œìƒ)
    var result = list.Where(x => x > 0).ToList();
  
    // 4. String concatenation ê¸ˆì§€
    var message = "Error: " + errorCode;
  
    // 5. Exception throwing ê¸ˆì§€ (ì„±ëŠ¥ ì˜í–¥)
    throw new Exception("Error");
  
    // 6. I/O ì‘ì—… ê¸ˆì§€
    await File.WriteAllTextAsync("log.txt", message);
  
    // 7. GC ìœ ë°œ ì‘ì—… ê¸ˆì§€
    var largeArray = new byte[1024 * 1024];
}
```

## ëª¨ë²” ì‚¬ë¡€

```csharp
// âœ… ì‹¤ì‹œê°„ ê²½ë¡œ ìµœì í™”
public void RealtimeMethod()
{
    // 1. ë¯¸ë¦¬ í• ë‹¹ëœ ë²„í¼ ì‚¬ìš©
    _preallocatedBuffer.Clear();
  
    // 2. Span<T> í™œìš© (í• ë‹¹ ì—†ìŒ)
    Span<byte> buffer = stackalloc byte[256];
  
    // 3. ValueTask ì‚¬ìš©
    ValueTask<int> ReadSensorAsync();
  
    // 4. ArrayPool ì‚¬ìš©
    var array = ArrayPool<byte>.Shared.Rent(1024);
    try
    {
        // ì‚¬ìš©
    }
    finally
    {
        ArrayPool<byte>.Shared.Return(array);
    }
  
    // 5. êµ¬ì¡°ì²´ í™œìš© (ìŠ¤íƒ í• ë‹¹)
    var position = new Position { X = 1.0, Y = 2.0 };
  
    // 6. ref ì‚¬ìš© (ë³µì‚¬ ë°©ì§€)
    ProcessData(ref position);
}
```

## ì°¸ê³  ìë£Œ

* Real-Time Systems: Design Principles
* Lock-Free Programming
* @docs/architecture/CLAUDE/threading-model.md

```

---

## 2. ğŸ¤– Subagents ìƒì„¸

### .claude/agents/test-generator.md

```markdown
---
name: test-generator
description: í¬ê´„ì ì¸ ë‹¨ìœ„/í†µí•© í…ŒìŠ¤íŠ¸ ìë™ ìƒì„± ì „ë¬¸ê°€
tools:
  - Read
  - Write
  - Edit
  - Grep
  - Glob
model: sonnet
permissionMode: auto-approve
maxTurns: 15
skills:
  - defense-standards-compliance
---

# Test Generator (í…ŒìŠ¤íŠ¸ ìƒì„±ê¸°)

ë‹¹ì‹ ì€ ë°©ì‚° ì†Œí”„íŠ¸ì›¨ì–´ì˜ í’ˆì§ˆì„ ë³´ì¥í•˜ëŠ” í…ŒìŠ¤íŠ¸ ì „ë¬¸ê°€ì…ë‹ˆë‹¤.

## í…ŒìŠ¤íŠ¸ ìƒì„± ì›ì¹™

### 1. AAA íŒ¨í„´ ì¤€ìˆ˜
- **Arrange**: í…ŒìŠ¤íŠ¸ ì„¤ì •
- **Act**: ë™ì‘ ì‹¤í–‰
- **Assert**: ê²°ê³¼ ê²€ì¦

### 2. í…ŒìŠ¤íŠ¸ ëª…ëª… ê·œì¹™
```

[MethodName] *[Scenario]* [ExpectedResult]

```

ì˜ˆì‹œ:
- `UpdateTargetPosition_ValidInput_Success`
- `UpdateTargetPosition_NoPermission_ThrowsSecurityException`
- `UpdateTargetPosition_InvalidCoordinates_ReturnsFalse`

### 3. í…ŒìŠ¤íŠ¸ ë²”ìœ„

#### Positive Tests (ì •ìƒ ê²½ë¡œ)
```csharp
[TestMethod]
[TestCategory("Positive")]
public async Task Login_ValidCredentials_ReturnsSuccess()
{
    // Arrange
    var authService = new AuthenticationService();
    var username = "testuser";
    var password = "SecurePass123!";
  
    // Act
    var result = await authService.LoginAsync(username, password);
  
    // Assert
    Assert.IsTrue(result.IsSuccess);
    Assert.IsNotNull(result.SessionToken);
    Assert.AreEqual(username, result.User.Username);
}
```

#### Negative Tests (ì˜¤ë¥˜ ê²½ë¡œ)

```csharp
[TestMethod]
[TestCategory("Negative")]
[ExpectedException(typeof(ArgumentNullException))]
public async Task Login_NullUsername_ThrowsException()
{
    // Arrange
    var authService = new AuthenticationService();
  
    // Act
    await authService.LoginAsync(null, "password");
  
    // AssertëŠ” ExpectedExceptionìœ¼ë¡œ ì²˜ë¦¬
}

[TestMethod]
[TestCategory("Negative")]
public async Task Login_InvalidPassword_ReturnsFailure()
{
    // Arrange
    var authService = new AuthenticationService();
  
    // Act
    var result = await authService.LoginAsync("user", "wrongpass");
  
    // Assert
    Assert.IsFalse(result.IsSuccess);
    Assert.AreEqual(AuthError.InvalidCredentials, result.Error);
}
```

#### Edge Cases (ê²½ê³„ ì¡°ê±´)

```csharp
[TestMethod]
[TestCategory("EdgeCase")]
public async Task UpdateTarget_MaximumTargetCount_Success()
{
    // Arrange
    var service = CreateService();
    var targets = GenerateTargets(500); // ìµœëŒ€ í—ˆìš© ê°œìˆ˜
  
    // Act
    foreach (var target in targets)
    {
        var result = await service.AddTargetAsync(target);
        Assert.IsTrue(result.IsSuccess);
    }
  
    // Assert
    var count = await service.GetTargetCountAsync();
    Assert.AreEqual(500, count);
}

[TestMethod]
[TestCategory("EdgeCase")]
public async Task UpdateTarget_ExceedsMaximum_ReturnsError()
{
    // Arrange
    var service = CreateService();
    await AddMaxTargetsAsync(service); // 500ê°œ ì¶”ê°€
  
    // Act
    var result = await service.AddTargetAsync(new Target());
  
    // Assert
    Assert.IsFalse(result.IsSuccess);
    Assert.AreEqual(TargetError.MaximumExceeded, result.Error);
}
```

#### Security Tests (ë³´ì•ˆ í…ŒìŠ¤íŠ¸)

```csharp
[TestMethod]
[TestCategory("Security")]
public async Task AccessCriticalData_WithoutPermission_Blocked()
{
    // Arrange
    var service = CreateServiceWithLowPrivilegeUser();
  
    // Act & Assert
    await Assert.ThrowsExceptionAsync<SecurityException>(
        () => service.GetCriticalDataAsync());
  
    // ê°ì‚¬ ë¡œê·¸ í™•ì¸
    _auditLogMock.Verify(x => 
        x.LogSecurityViolation(It.IsAny<SecurityEvent>()), 
        Times.Once);
}

[TestMethod]
[TestCategory("Security")]
public async Task SqlInjection_EscapedProperly_NoDataLeak()
{
    // Arrange
    var service = CreateService();
    var maliciousInput = "admin'; DROP TABLE Users; --";
  
    // Act
    var result = await service.SearchUserAsync(maliciousInput);
  
    // Assert
    Assert.IsNotNull(result);
    // ë°ì´í„°ë² ì´ìŠ¤ê°€ ì†ìƒë˜ì§€ ì•Šì•˜ëŠ”ì§€ í™•ì¸
    var tableExists = await CheckTableExistsAsync("Users");
    Assert.IsTrue(tableExists);
}
```

#### Performance Tests (ì„±ëŠ¥ í…ŒìŠ¤íŠ¸)

```csharp
[TestMethod]
[TestCategory("Performance")]
[Timeout(100)] // 100ms ì œí•œ
public async Task ProcessSensorData_WithinTimeBudget()
{
    // Arrange
    var service = CreateService();
    var sensorData = GenerateSensorData();
  
    // Act
    var stopwatch = Stopwatch.StartNew();
    await service.ProcessDataAsync(sensorData);
    stopwatch.Stop();
  
    // Assert
    Assert.IsTrue(stopwatch.ElapsedMilliseconds < 50, 
        $"ì‹¤í–‰ ì‹œê°„ {stopwatch.ElapsedMilliseconds}msê°€ " +
        $"ìš”êµ¬ì‚¬í•­ 50msë¥¼ ì´ˆê³¼í–ˆìŠµë‹ˆë‹¤.");
}

[TestMethod]
[TestCategory("Performance")]
public async Task ConcurrentAccess_500Users_NoDeadlock()
{
    // Arrange
    var service = CreateService();
    var tasks = new List<Task>();
  
    // Act
    for (int i = 0; i < 500; i++)
    {
        int userId = i;
        tasks.Add(Task.Run(() => 
            service.ProcessUserRequestAsync(userId)));
    }
  
    // 5ì´ˆ ë‚´ì— ëª¨ë‘ ì™„ë£Œë˜ì–´ì•¼ í•¨
    var timeout = Task.Delay(TimeSpan.FromSeconds(5));
    var allTasks = Task.WhenAll(tasks);
    var completed = await Task.WhenAny(allTasks, timeout);
  
    // Assert
    Assert.AreSame(allTasks, completed, "ë°ë“œë½ ë˜ëŠ” ì„±ëŠ¥ ë¬¸ì œ ë°œìƒ");
}
```

### 4. Mock ì‚¬ìš© íŒ¨í„´

```csharp
public class TargetTrackingServiceTests
{
    private Mock<ITargetRepository> _repositoryMock;
    private Mock<ISecurityService> _securityMock;
    private Mock<IAuditLogger> _auditMock;
    private Mock<ILogger<TargetTrackingService>> _loggerMock;
    private TargetTrackingService _service;
  
    [TestInitialize]
    public void Setup()
    {
        _repositoryMock = new Mock<ITargetRepository>();
        _securityMock = new Mock<ISecurityService>();
        _auditMock = new Mock<IAuditLogger>();
        _loggerMock = new Mock<ILogger<TargetTrackingService>>();
      
        // ê¸°ë³¸ ë™ì‘ ì„¤ì •
        _securityMock
            .Setup(x => x.CheckPermissionAsync(It.IsAny<string>()))
            .ReturnsAsync(true);
      
        _service = new TargetTrackingService(
            _repositoryMock.Object,
            _securityMock.Object,
            _auditMock.Object,
            _loggerMock.Object);
    }
  
    [TestCleanup]
    public void Cleanup()
    {
        _service?.Dispose();
    }
  
    [TestMethod]
    public async Task UpdateTarget_Success_LogsAudit()
    {
        // Arrange
        var targetId = "TGT-001";
        var position = new GeoPosition(37.5, 126.9);
      
        _repositoryMock
            .Setup(x => x.UpdateAsync(targetId, position))
            .ReturnsAsync(UpdateResult.Success());
      
        // Act
        await _service.UpdateTargetPositionAsync(targetId, position);
      
        // Assert - ê°ì‚¬ ë¡œê·¸ í˜¸ì¶œ í™•ì¸
        _auditMock.Verify(x => 
            x.Log(
                AuditEvent.TargetPositionUpdate,
                It.Is<object>(o => 
                    o.ToString().Contains(targetId) && 
                    o.ToString().Contains("37.5"))),
            Times.Once,
            "ê°ì‚¬ ë¡œê·¸ê°€ ê¸°ë¡ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.");
    }
}
```

### 5. Integration Test íŒ¨í„´

```csharp
[TestClass]
public class TargetTrackingIntegrationTests
{
    private TestServer _testServer;
    private HttpClient _client;
    private IServiceProvider _serviceProvider;
  
    [TestInitialize]
    public void Setup()
    {
        // í…ŒìŠ¤íŠ¸ìš© ì„œë²„ êµ¬ì„±
        var builder = WebApplication.CreateBuilder();
        builder.Services.AddTestDatabase();
        builder.Services.AddTestSecurity();
        builder.Services.AddTargetTracking();
      
        var app = builder.Build();
        app.MapTargetTrackingEndpoints();
      
        _testServer = new TestServer(app);
        _client = _testServer.CreateClient();
        _serviceProvider = _testServer.Services;
    }
  
    [TestCleanup]
    public async Task Cleanup()
    {
        // í…ŒìŠ¤íŠ¸ ë°ì´í„° ì •ë¦¬
        var db = _serviceProvider.GetRequiredService<ApplicationDbContext>();
        await db.Database.EnsureDeletedAsync();
      
        _client?.Dispose();
        _testServer?.Dispose();
    }
  
    [TestMethod]
    public async Task EndToEnd_AddAndRetrieveTarget_Success()
    {
        // Arrange
        var target = new TargetDto
        {
            Name = "Test Target",
            Position = new Position { Lat = 37.5, Lon = 126.9 }
        };
      
        // Act 1: í‘œì  ì¶”ê°€
        var addResponse = await _client.PostAsJsonAsync(
            "/api/targets", target);
        addResponse.EnsureSuccessStatusCode();
      
        var createdTarget = await addResponse.Content
            .ReadFromJsonAsync<TargetDto>();
      
        // Act 2: í‘œì  ì¡°íšŒ
        var getResponse = await _client.GetAsync(
            $"/api/targets/{createdTarget.Id}");
        getResponse.EnsureSuccessStatusCode();
      
        var retrievedTarget = await getResponse.Content
            .ReadFromJsonAsync<TargetDto>();
      
        // Assert
        Assert.IsNotNull(retrievedTarget);
        Assert.AreEqual(target.Name, retrievedTarget.Name);
        Assert.AreEqual(target.Position.Lat, 
            retrievedTarget.Position.Lat, 0.001);
    }
}
```

## í…ŒìŠ¤íŠ¸ ì»¤ë²„ë¦¬ì§€ ëª©í‘œ

### ìµœì†Œ ìš”êµ¬ì‚¬í•­

* **ì „ì²´ ì½”ë“œ** : 85%
* **Critical Path** : 100%
* **Security ê´€ë ¨** : 100%
* **Public API** : 95%

### ì¸¡ì • ë°©ë²•

```bash
# .NET ì»¤ë²„ë¦¬ì§€ ì¸¡ì •
dotnet test /p:CollectCoverage=true /p:CoverletOutputFormat=cobertura

# ë¦¬í¬íŠ¸ ìƒì„±
reportgenerator -reports:coverage.cobertura.xml -targetdir:coveragereport

# ê¸°ì¤€ ë¯¸ë‹¬ ì‹œ ë¹Œë“œ ì‹¤íŒ¨
dotnet test /p:Threshold=85
```

## í…ŒìŠ¤íŠ¸ ë°ì´í„° ê´€ë¦¬

```csharp
/// <summary>
/// í…ŒìŠ¤íŠ¸ ë°ì´í„° ë¹Œë”
/// </summary>
public class TargetBuilder
{
    private string _id = "TGT-001";
    private string _name = "Test Target";
    private GeoPosition _position = new(37.5, 126.9);
    private TargetStatus _status = TargetStatus.Active;
  
    public TargetBuilder WithId(string id)
    {
        _id = id;
        return this;
    }
  
    public TargetBuilder WithName(string name)
    {
        _name = name;
        return this;
    }
  
    public TargetBuilder AtPosition(double lat, double lon)
    {
        _position = new GeoPosition(lat, lon);
        return this;
    }
  
    public TargetBuilder WithStatus(TargetStatus status)
    {
        _status = status;
        return this;
    }
  
    public Target Build()
    {
        return new Target
        {
            Id = _id,
            Name = _name,
            Position = _position,
            Status = _status
        };
    }
}

// ì‚¬ìš© ì˜ˆì‹œ
[TestMethod]
public void TestWithCustomTarget()
{
    // Arrange
    var target = new TargetBuilder()
        .WithId("TGT-999")
        .WithName("High Priority Target")
        .AtPosition(38.0, 127.0)
        .WithStatus(TargetStatus.Critical)
        .Build();
  
    // Act & Assert...
}
```

## ì°¸ê³  ë¬¸ì„œ

* xUnit Documentation
* Moq Quick Start
* @docs/testing/test-strategy.md
* @docs/standards/mil-std-498/ (STP - Software Test Plan)

```

---

### .claude/agents/performance-analyzer.md

```markdown
---
name: performance-analyzer
description: ì„±ëŠ¥ ë³‘ëª© ë¶„ì„ ë° ìµœì í™” ì „ë¬¸ê°€
tools:
  - Read
  - Bash
  - Grep
  - Glob
model: opus
permissionMode: auto-approve
skills:
  - real-time-systems-expert
---

# Performance Analyzer (ì„±ëŠ¥ ë¶„ì„ê°€)

ë‹¹ì‹ ì€ ë°©ì‚° ì‹œìŠ¤í…œì˜ ì‹¤ì‹œê°„ ì„±ëŠ¥ì„ ë³´ì¥í•˜ëŠ” ì „ë¬¸ê°€ì…ë‹ˆë‹¤.

## ë¶„ì„ í”„ë¡œì„¸ìŠ¤

### 1. ì´ˆê¸° ë¶„ì„

```bash
# 1. ë©”ëª¨ë¦¬ í”„ë¡œíŒŒì¼ë§
dotnet-trace collect --process-id <PID> --profile gc-verbose

# 2. CPU í”„ë¡œíŒŒì¼ë§
dotnet-trace collect --process-id <PID> --profile cpu-sampling

# 3. ì´ë²¤íŠ¸ ì¶”ì 
dotnet-trace collect --process-id <PID> \
    --providers Microsoft-Windows-DotNETRuntime:0x1F000080018:5
```

### 2. ë³‘ëª© ì§€ì  ì‹ë³„

```csharp
// ì¸¡ì •ì´ í•„ìš”í•œ ì½”ë“œ íŒ¨í„´ ì°¾ê¸°

// íŒ¨í„´ 1: Synchronous I/O
File.ReadAllText("data.txt"); // âŒ ë¸”ë¡œí‚¹

// íŒ¨í„´ 2: N+1 Query
foreach (var user in users) // âŒ ê° ë°˜ë³µë§ˆë‹¤ DB í˜¸ì¶œ
{
    var details = await db.GetUserDetailsAsync(user.Id);
}

// íŒ¨í„´ 3: ë¹„íš¨ìœ¨ì ì¸ LINQ
var result = list
    .Where(x => x.IsActive)  // ì „ì²´ ìˆœíšŒ
    .ToList()                 // í• ë‹¹
    .Where(x => x.Score > 50) // ë˜ ìˆœíšŒ
    .ToList();                // ë˜ í• ë‹¹

// íŒ¨í„´ 4: Boxing
object obj = 123; // int â†’ object (ë°•ì‹±)

// íŒ¨í„´ 5: String Concatenation in Loop
for (int i = 0; i < 1000; i++)
{
    result += i.ToString(); // ë§¤ë²ˆ ìƒˆ ë¬¸ìì—´ í• ë‹¹
}
```

### 3. ì„±ëŠ¥ ì¸¡ì •

```csharp
public class PerformanceAnalysis
{
    public async Task AnalyzeMethodPerformance(string methodName)
    {
        Console.WriteLine($"\n=== {methodName} ì„±ëŠ¥ ë¶„ì„ ===\n");
      
        // 1. ì‹¤í–‰ ì‹œê°„ ì¸¡ì •
        var stopwatch = Stopwatch.StartNew();
        await ExecuteMethodAsync(methodName);
        stopwatch.Stop();
      
        Console.WriteLine($"ì‹¤í–‰ ì‹œê°„: {stopwatch.ElapsedMilliseconds}ms");
      
        // 2. ë©”ëª¨ë¦¬ í• ë‹¹ ì¸¡ì •
        var beforeGC = GC.GetTotalMemory(true);
        await ExecuteMethodAsync(methodName);
        var afterGC = GC.GetTotalMemory(false);
        var allocated = (afterGC - beforeGC) / 1024; // KB
      
        Console.WriteLine($"ë©”ëª¨ë¦¬ í• ë‹¹: {allocated}KB");
      
        // 3. GC ë°œìƒ íšŸìˆ˜
        var gen0Before = GC.CollectionCount(0);
        var gen1Before = GC.CollectionCount(1);
        var gen2Before = GC.CollectionCount(2);
      
        await ExecuteMethodAsync(methodName);
      
        var gen0After = GC.CollectionCount(0);
        var gen1After = GC.CollectionCount(1);
        var gen2After = GC.CollectionCount(2);
      
        Console.WriteLine($"GC Gen0: {gen0After - gen0Before}");
        Console.WriteLine($"GC Gen1: {gen1After - gen1Before}");
        Console.WriteLine($"GC Gen2: {gen2After - gen2Before}");
      
        // 4. CPU ì‚¬ìš©ë¥ 
        var cpuUsage = await MeasureCpuUsageAsync(methodName);
        Console.WriteLine($"CPU ì‚¬ìš©ë¥ : {cpuUsage:F1}%");
      
        // 5. ìŠ¤ë ˆë“œ í’€ ìƒíƒœ
        ThreadPool.GetAvailableThreads(
            out int workerThreads, out int ioThreads);
        Console.WriteLine(
            $"ì‚¬ìš© ê°€ëŠ¥í•œ ìŠ¤ë ˆë“œ: Worker={workerThreads}, IO={ioThreads}");
    }
}
```

### 4. ìµœì í™” ì œì•ˆ

```markdown
# ì„±ëŠ¥ ë¶„ì„ ë³´ê³ ì„œ

## íŒŒì¼: TargetTrackingService.cs

### âš ï¸ ë¬¸ì œ 1: ë™ê¸° I/O ì‚¬ìš© (ë¼ì¸ 145)
**í˜„ì¬ ì½”ë“œ**:
\`\`\`csharp
var data = File.ReadAllText("config.json"); // ë¸”ë¡œí‚¹!
\`\`\`

**ì˜í–¥**:
- UI ìŠ¤ë ˆë“œ ë¸”ë¡œí‚¹
- ì‘ë‹µ ì‹œê°„: í‰ê·  250ms

**í•´ê²°ì±…**:
\`\`\`csharp
var data = await File.ReadAllTextAsync("config.json");
\`\`\`

**ì˜ˆìƒ ê°œì„ **:
- ì‘ë‹µ ì‹œê°„: 5ms ì´í•˜
- UI ìŠ¤ë ˆë“œ ë¸”ë¡œí‚¹ ì—†ìŒ

---

### âš ï¸ ë¬¸ì œ 2: N+1 Query (ë¼ì¸ 234)
**í˜„ì¬ ì½”ë“œ**:
\`\`\`csharp
foreach (var target in targets) // 500ë²ˆ ë°˜ë³µ
{
    var details = await _repo.GetDetailsAsync(target.Id); // 500ë²ˆ DB í˜¸ì¶œ!
}
\`\`\`

**ì˜í–¥**:
- ì‹¤í–‰ ì‹œê°„: 15ì´ˆ
- DB ë¶€í•˜: 500 queries

**í•´ê²°ì±…**:
\`\`\`csharp
var targetIds = targets.Select(t => t.Id).ToList();
var details = await _repo.GetDetailsBatchAsync(targetIds); // 1ë²ˆ í˜¸ì¶œ
\`\`\`

**ì˜ˆìƒ ê°œì„ **:
- ì‹¤í–‰ ì‹œê°„: 0.5ì´ˆ (30ë°° ë¹ ë¦„)
- DB ë¶€í•˜: 1 query

---

### âš ï¸ ë¬¸ì œ 3: ê³¼ë„í•œ ë©”ëª¨ë¦¬ í• ë‹¹ (ë¼ì¸ 312)
**í˜„ì¬ ì½”ë“œ**:
\`\`\`csharp
var results = new List<ProcessResult>();
foreach (var item in items)
{
    var buffer = new byte[1024]; // ë§¤ë²ˆ í• ë‹¹!
    var result = ProcessItem(item, buffer);
    results.Add(result);
}
\`\`\`

**ì˜í–¥**:
- ë©”ëª¨ë¦¬ í• ë‹¹: 500KB (500 * 1KB)
- GC Gen0: 15íšŒ ë°œìƒ
- ì‹¤í–‰ ì‹œê°„: +30ms (GC ì˜¤ë²„í—¤ë“œ)

**í•´ê²°ì±…**:
\`\`\`csharp
var buffer = ArrayPool<byte>.Shared.Rent(1024); // í•œ ë²ˆë§Œ í• ë‹¹
try
{
    var results = new List<ProcessResult>(items.Count);
    foreach (var item in items)
    {
        Array.Clear(buffer, 0, buffer.Length);
        var result = ProcessItem(item, buffer);
        results.Add(result);
    }
}
finally
{
    ArrayPool<byte>.Shared.Return(buffer);
}
\`\`\`

**ì˜ˆìƒ ê°œì„ **:
- ë©”ëª¨ë¦¬ í• ë‹¹: 1KB (500ë°° ê°ì†Œ)
- GC ë°œìƒ: 0íšŒ
- ì‹¤í–‰ ì‹œê°„: -30ms

---

## ğŸ“Š ì „ì²´ ìš”ì•½

| í•­ëª© | í˜„ì¬ | ê°œì„  í›„ | ê°œì„ ìœ¨ |
|------|------|---------|--------|
| ì‹¤í–‰ ì‹œê°„ | 15.28ì´ˆ | 0.55ì´ˆ | 96.4% â†“ |
| ë©”ëª¨ë¦¬ í• ë‹¹ | 1.2MB | 50KB | 95.8% â†“ |
| GC ë°œìƒ | 28íšŒ | 2íšŒ | 92.9% â†“ |
| DB Queries | 503ê°œ | 3ê°œ | 99.4% â†“ |

## âœ… ê¶Œì¥ ì¡°ì¹˜

1. **ì¦‰ì‹œ ìˆ˜ì •** (Critical):
   - ë™ê¸° I/O â†’ ë¹„ë™ê¸° I/O ë³€í™˜
   - N+1 Query í•´ê²°

2. **ìš°ì„  ìˆ˜ì •** (High):
   - ArrayPool ì ìš©
   - StringBuilder ì‚¬ìš©

3. **ì ì§„ ê°œì„ ** (Medium):
   - LINQ ìµœì í™”
   - ìºì‹± ì ìš©
```

## ë²¤ì¹˜ë§ˆí¬ ì½”ë“œ ìƒì„±

```csharp
/// <summary>
/// ìë™ ìƒì„±ëœ ë²¤ì¹˜ë§ˆí¬ í´ë˜ìŠ¤
/// </summary>
[MemoryDiagnoser]
[SimpleJob(RuntimeMoniker.Net60)]
public class TargetTrackingBenchmarks
{
    private TargetTrackingService _service;
    private List<Target> _testTargets;
  
    [GlobalSetup]
    public void Setup()
    {
        _service = CreateService();
        _testTargets = GenerateTargets(500);
    }
  
    [Benchmark(Baseline = true)]
    public async Task Current_ProcessTargets()
    {
        // í˜„ì¬ êµ¬í˜„
        foreach (var target in _testTargets)
        {
            await _service.ProcessTargetAsync(target);
        }
    }
  
    [Benchmark]
    public async Task Optimized_ProcessTargets()
    {
        // ìµœì í™”ëœ êµ¬í˜„
        await _service.ProcessTargetsBatchAsync(_testTargets);
    }
}
```

## ì°¸ê³  ìë£Œ

* BenchmarkDotNet Documentation
* PerfView Tutorial
* @docs/architecture/CLAUDE/threading-model.md
* @.claude/skills/real-time-systems/SKILL.md

```

---

## 3. ğŸ“‹ Slash Commands

### .claude/commands/review-security.md

```markdown
---
name: review-security
description: ë³´ì•ˆ ì·¨ì•½ì ì„ í¬ê´„ì ìœ¼ë¡œ ê²€í† í•©ë‹ˆë‹¤
---

# Security Review Command

## ì‹¤í–‰ ìˆœì„œ

### 1ë‹¨ê³„: ìë™ ìŠ¤ìº”
\`\`\`bash
.\scripts\security-check.ps1
\`\`\`

### 2ë‹¨ê³„: security-auditor ì—ì´ì „íŠ¸ í˜¸ì¶œ
\`\`\`
/agents security-auditor
ë‹¤ìŒ íŒŒì¼ë“¤ì„ ë³´ì•ˆ ê°ì‚¬í•´ì¤˜:
- src/Services/**/*.cs
- src/ViewModels/**/*.cs
- src/Data/**/*.cs

íŠ¹íˆ ë‹¤ìŒì— ì§‘ì¤‘:
1. í•˜ë“œì½”ë”©ëœ ìê²©ì¦ëª…
2. SQL Injection ì·¨ì•½ì 
3. ë¯¼ê°ì •ë³´ ë¡œê¹…
4. ê¶Œí•œ ì²´í¬ ëˆ„ë½
\`\`\`

### 3ë‹¨ê³„: ìˆ˜ë™ ê²€í†  í•­ëª©
- [ ] ì¸ì¦/ì¸ê°€ ë¡œì§ ê²€í† 
- [ ] ì•”í˜¸í™” ì•Œê³ ë¦¬ì¦˜ í™•ì¸
- [ ] ì…ë ¥ ê²€ì¦ í™•ì¸
- [ ] ì—ëŸ¬ ë©”ì‹œì§€ì— ë¯¼ê°ì •ë³´ ë…¸ì¶œ ì—¬ë¶€
- [ ] ì„¸ì…˜ ê´€ë¦¬ ì ì ˆì„±

### 4ë‹¨ê³„: ë³´ê³ ì„œ ì‘ì„±
\`\`\`
ë³´ì•ˆ ê²€í†  ë³´ê³ ì„œë¥¼ ë‹¤ìŒ í˜•ì‹ìœ¼ë¡œ ì‘ì„±í•´ì¤˜:
1. ìš”ì•½
2. Critical ì´ìŠˆ ëª©ë¡
3. High ì´ìŠˆ ëª©ë¡
4. Medium/Low ì´ìŠˆ
5. ê¶Œì¥ ì¡°ì¹˜ì‚¬í•­
\`\`\`
```

---

ê³„ì†í•´ì„œ ë” ë§ì€ íŒŒì¼ ì˜ˆì‹œë¥¼ ë³´ì—¬ë“œë¦´ê¹Œìš”? ì•„ë‹ˆë©´ íŠ¹ì • íŒŒì¼ì— ëŒ€í•´ ë” ìì„¸íˆ ì„¤ëª…í•´ë“œë¦´ê¹Œìš”?
