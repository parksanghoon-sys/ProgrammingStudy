"클린코더스 객체지향프로그래밍"에 대해 검색해보겠습니다.더 자세한 내용을 확인해보겠습니다.## 클린코더스 - 객체지향 프로그래밍(OOP)

백명석님의 **클린코더스** 강의는 Robert C. Martin(Uncle Bob)의 Clean Code 철학을 바탕으로 한 한국어 강의 시리즈입니다. OOP 파트는 이 시리즈의 기초를 다지는 핵심 부분이에요.

---

### 전체 강의 흐름

강의는 다음 순서로 진행됩니다:

**기초** → OOP (Part 1~2) → Function (Part 1~2) → Function Structure → Form

**실전** → TDD (1~4) → Architecture → Architecture UseCase

**설계 원칙** → SOLID Foundation → SRP → OCP → LSP → ISP → DIP → Case Study

---

### OOP 강의 핵심 내용

**1. Why Clean Code?**

코드 1줄 수정 시 평균 3줄에서 버그가 발생하고, 프로젝트 후반 수정은 10~100배 비용이 든다는 점을 강조합니다. 한번 작성된 코드는 최소 10번 이상 읽히기 때문에 가독성이 중요합니다.

**2. 절차지향 vs 객체지향**

절차지향은 초기 진입이 쉽지만 데이터 변경이 전체 프로시저에 영향을 미칩니다. 반면 객체지향은 데이터와 코드가 캡슐화되어 있어 변경의 영향 범위가 해당 객체로 제한됩니다.

**3. 객체/역할/책임 (Object/Role/Responsibility)**

핵심 인사이트가 여기에 있는데요:

* 클래스 이름은 "어떻게"가 아닌 **"무엇"**으로 정의
* `ArticleService` ❌ → `WriteArticleService`, `PublishArticle` ✅
* 객체를 **데이터**로 보지 말고 **기능/책임**으로 봐야 함
* 다른 객체의 값을 가져와 판단하지 말고, 그 객체에게 물어봐라 (`member.isExpired()`)

**4. 캡슐화 (Encapsulation)**

내부 구현을 감춰서 Client가 내부 변경에 영향받지 않도록 합니다. 절차지향은 기능 변경 시 데이터를 사용하는 모든 코드 수정이 필요하지만, 객체지향은 변경 범위가 제한적입니다.

**5. 다형성 (Polymorphism)**

상속을 통해 구현하며 재사용성의 핵심입니다:

* 저수준 구현체가 변경되어도 고수준 비즈니스 로직은 보호됨
* 새 구현체 추가 시 기존 코드 변경 불필요
* DI로 풀지 않으면 Mock 객체로 테스트하기 어려움

**6. 추상화 (Abstraction)**

고수준 비즈니스 로직을 저수준 구현 세부사항으로부터 보호합니다:

```
❌ 잘못된 추상화
디렉토리에서 파일 읽기 → 정규표현식 파싱 → DB 저장

✅ 올바른 추상화  
로그 수집 → 로그 분석 → 결과 저장
```

---

### 핵심 메시지 요약

백명석님이 강조하는 OOP의 본질은 "변경에 유연한 코드"입니다. 구현체가 지금은 1개여도 미래에 2개가 될 수 있으므로, 팩토리 메소드나 DI를 활용해 변경에 대비해야 한다는 점을 계속 강조합니다.

강의 자료는 [GitHub](https://github.com/msbaek/clean-coders-2013)에서, 영상은 YouTube에서 "백명석 클린코더스"로 검색하면 볼 수 있어요!
