# 참조 타입과 값 타입
CLR은 참조타입과 값 타입 이라는 두 종류의 타입 체계를 지원.  
<br>
## 1.1. 참조 타입 (ReferenceType)
**참조타입은 항상 관리되는 힙에 할당이 된다,** 참조타입을 사용할 때 마다 메모리의 할당이 발생하는데, 모든 타입이 참조 타입이면 성능 저하가 있을것이다.  
**예를들면 배열, 열거, 클래스, 인터페이스를 말한다, 선언된 변수는 실제 값을 변수에 저장하지만 참조타입으로 선언된 변수는 메모리의 주소값을 변수안에 저장한다.**  
따라서 단순하고 자주 사용되는 타입을 위해 경량화된 값 타입이 존재한다. 값 타입의 인스턴스는 그 자체가 하나의 필드이며 필드를 얻기위해 역추적을 할 필요가 없고 GC의 관리 대상또한 아니다. Class
<br>
## 1.2. 값 타입 (Value Type)
**객체의 속성중 기본형과 같은 단순한 값을 의미한다.** 예를 들어 int, double 같은 primitive type이나 String 같은 클래스도 참조는 가지지만 값의 변경을 추적할수없어 Value 타입에 속한다.  
* String은 참조타입이지만 값타입처럼 동작한다. string은 내부적으로 문자열을 char 개체의 순차적 읽기 컬렉션으로 저장된다
* Sttring은 값타입처럼 동작 이유는 immutable하기떄문, 즉 **String 값을 변경시 새로운 string 개체가 생성되고 이전 string 은 GC에의해 수집된다.** 

Value Type은 불변객체로 설계해야한다. 생성자로만 값을 설정하고 수정자를 만들지 않으면 안된다.  
## 1.3. 값 타입의 만족조건
* 새로만드는 타입이 기본타입 처럼 쓰인다.
* 다른 타입으로부터 상속 받을 필요가 없다.
* 다른 타입의 기본타입으로 쓰이게 할 계획이 없다.
* 인스턴스의 전체 크기가 약 16바이트 이내로 매우 작다
* 인스턴스가 16바이트 보다 크지만 메서드의 매개변수나 반환 타입으로 쓰이는 일이 없음을 확실히 할수있다.
## 1.4. 값 타입과  참조타입의 비교
| 값 타입|참조 타입|
|---|---|
|Sytem.ValueType 타입으로부터 항상 상속, Equals메서드를 재정의 하여 두 객체의 필드값이 일치시 true를 반환한다(Object는 참조가 같을때 true)|참조타입의 변수는 객체의 메모리죽소가 힙을 같는다. 값타입의 경우 모든 필드 맴버를 0으로 초기화한다|
|가상 함수를 만들수 없다, 모든 메서드는 암묵적으로 재정의가 불가하다 생성시 데이터 전달을 해야한다.|상속매개체로 사용이 가능하다|
|박싱이 되지 않은 상태로 할당시 메서드와 함께 선언되고 메서드의 실행이 끝나면 메모리가 할당을 해지한다|GC를 만날때 까지 기다린다|
|별수를 다른 값 타입의 변수로 대입시 필드 단위로 하나씩 복제가 이루어진다|변수끼리 대입이 발생시 메모리 주소만 복제 된다.|

<br>
값 타입은 스택에 할당되고 참조 타입은 힙에 할당됩니다1. 값 타입은 스택에서 바로 사용할 수 있기 때문에 참조 타입보다 더 빠르게 인스턴스를 할당할 수 있습니다1. 그러나 값 타입이 참조 타입보다 항상 빠르다는 것은 아닙니다

또한 값 타입은 복사될 때마다 새로운 인스턴스가 생성되기 때문에 메모리 사용량이 더 많아질 수 있습니다

---
# 값 타입의 박싱과 언박싱
## 1.1. 박싱
값 타입은 참조타입보다 가볍다, 힙에 객체로 할당되지 않으며, GC가 관리하지 않고 포인터로 가리켜지지 않는다. 그러나 값타입에 대한 참조를 얻어야할떄가 있는데 Array같은 컬렉션이다.  
아래 예제를 보자
```c#
struct Vector2Int
{
    public int x, y;
}

public sealed class Program
{
    public static void Main()
    {
        ArrayList arr = new ArrayList();
        Vector2Int v; // 힙 밖에 생성된다.
        for(int i=0;i<10; ++i)
        {
            v.x = v.y = i; // 값 타입을 초기화해야함 (new를 사용하지 않았으므로)
            arr.Add(v); // 뭐가 들어갈까?
        }
    }
}
```
arr.Add(v) 가 호출되면 arr에 무엇이들어갈까 Vector2Int 구조체일까 아니면 구조체의 주소일까??   
<br>
ArrayList의 Add는 object를 매개변수로 받는다 즉 관리된는 힙 상의 객체의 주소이다.
하지만 Vector2Int는 구조체이기 떄문에 값타입이고 따라서 arr에 더해지기위해 참조타입으로 변환이 되어야한다. 그래서 다음과 같은 일이 발생한다.
* 관리되는 힙에 메모리가 할당된다. 이때 메모리의 크기는 값 타입내에 들어있는 필드들의 메모리 크기에 더하여 다른 힙 객체들처럼 **타입객체 포인터와 동기화 블록 인덱스를 포함한다**.
* **값 타입의 필드들이 새로 할당된 힙 메모리에 복사된다.**
* 객체의 메모리 주소가 바놘된다. 주소는 이제 객체에대한 참조이며 값 타입은 참조 타입으로 취급된다, 이제 값 타입은 다른 참조타입처럼 GC를 만날 때 까지 메모리에 남는다.

> 근데 이제 제너릭 컬렉션들이 나왔으니까 이걸 쓰면 됨. 얘네는 박싱도 언박싱도 일어나지 않아서 성능상에 큰 이점이 있다.

## 언박싱
위에서 만든 ArrayList에 담겨있는 요소를 가져온다고 해보자
```c#
Point p = (Point) a[0];
```
a[0] 은 참조타입이지만 이것을 값 타입인 p에 넣으려고 하고 있다. 이것은 a[0]안의 필드들을 p의 필드에 복사하는 것인데 CLR은 이 과정을 두 단계에 걸쳐서 수행한다.

박싱된 Point 타입에 들어있는 Point 필드들의 주소를 가져온다. (언박싱)
이 필드들의 값을 힙에서 복사하여 스택의 값 타입 인스턴스 쪽으로 복사해 넣는다
언박싱은 박싱보다는 훨씬 적은 연산을 수행한다. 박싱은 메모리 복사를 수반하는데 비해 언박싱은 그렇지 않기 때문이다.  그러나 둘 다 성능 저하를 일으키게 되는건 마찬가지임.

또한 박싱된 객체를 다시 언박싱하는 캐스트를 수행할 때, 원래의 타입과 똑같은 타입으로 지정해주어야 한다. Int32 객체를 박싱한 후, Int16으로 캐스팅하면 InvalidCastException이 발생한다.

## 박싱되지 않은 값 타입이 참조 타입보다 가벼운 이요
1. 관리 되는 힙 메모리가 아닌 스텍 메모리에 공간 할당
2. 힙 메모리상에 할당되는 참조타입 객체들은 기본적으로 타입 객체 포인터와 동기화 블록 인덱스라는 두개의 추가 필드가 자동으로 할당됨