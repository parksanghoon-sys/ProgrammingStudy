
# C# 비동기 프로그래밍의 정석: TAP(Task-based Asynchronous Pattern) 파헤치기

이 문서는 .NET의 비동기 프로그래밍이 어떻게 발전해왔는지 설명하고, 현대적인 비동기 방식인 TAP의 핵심 설계 원칙과 개념을 다룹니다.

---

### 1. 비동기 패턴의 진화: APM/EAP에서 TAP으로 🚀

과거 .NET에는 두 가지 주요 비동기 패턴이 있었습니다.

* **APM (비동기 프로그래밍 모델)** : `BeginRead`와 `EndRead`처럼 시작/종료 메서드가 쌍을 이루는 복잡한 방식입니다.
* **EAP (이벤트 기반 비동기 패턴)** : `ReadAsync` 메서드를 호출하고 `ReadCompleted` 이벤트를 통해 결과를 받는 방식입니다.

이 두 패턴은 번거롭고 오류가 발생하기 쉬웠습니다. 이를 해결하기 위해 **TAP (작업 기반 비동기 패턴)**이 등장했습니다. TAP는 `Task` 또는 `Task<TResult>` 객체 하나로 전체 비동기 작업을 표현하여 코드를 획기적으로 단순화했습니다. `async/await` 키워드 덕분에 비동기 코드를 동기 코드처럼 쉽게 작성할 수 있게 되었습니다.

---

### 2. TAP 메서드 명명 규칙 🏷️

TAP는 일관성을 위해 다음과 같은 명명 및 시그니처 규칙을 따릅니다.

* **`Async` 접미사** : 비동기 메서드 이름은 항상 `Async`로 끝납니다. (예: `GetData` -> `GetDataAsync`)
* **반환 타입** :
* 동기 메서드가 `void`를 반환하면 비동기 메서드는 `Task`를 반환합니다.
* 동기 메서드가 `T` 타입의 값을 반환하면 비동기 메서드는 `Task<T>`를 반환합니다.
* **`out`, `ref` 매개변수 금지** : TAP에서는 `out`이나 `ref` 매개변수를 사용하지 않고, 대신 여러 결과 값을 튜플(Tuple)이나 사용자 정의 클래스에 담아 `Task<T>`로 반환합니다.
* **`CancellationToken`과 `IProgress<T>`** : 선택적으로 **취소**를 위한 `CancellationToken`과 **진행률 보고**를 위한 `IProgress<T>` 매개변수를 포함하는 것이 좋습니다.

---

### 3. 비동기 작업의 시작: 빠른 실행 ⚡

TAP 메서드는 호출 즉시 최소한의 동기 작업(주로 인수 유효성 검사)만 수행한 후, 빠르게 `Task` 객체를 반환해야 합니다. 실제 오래 걸리는 작업은 백그라운드에서 실행됩니다.

* **이유** : UI 스레드를 막지 않고 응답성을 유지하며, 여러 비동기 작업을 동시에 시작할 때 병목 현상을 방지하기 위함입니다.
* **빠른 완료** : 만약 요청된 데이터가 이미 캐시에 있는 등 작업이 즉시 완료될 수 있다면, 이미 완료된 상태의 `Task`를 반환하여 불필요한 오버헤드를 줄일 수도 있습니다.

---

### 4. 예외 처리 원칙 🛡️

TAP의 예외 처리는 매우 중요한 원칙을 따릅니다.

> **사용 오류(Usage errors)는 즉시 던지고, 작업 오류(Operational errors)는 `Task`에 담아라.**

* **사용 오류** : `ArgumentNullException`처럼 메서드 인자를 잘못 전달한 경우는 **즉시 동기적으로 예외를 발생**시킵니다. 이는 개발자의 실수를 바로 잡기 위함입니다.
* **작업 오류** : 네트워크 오류처럼 비동기 작업 **도중에 발생한 예외는 `Task` 내부에 저장**됩니다. 이 `Task`는 `Faulted`(오류) 상태가 되며, 호출자가 이 `Task`를 `await`하는 시점에 저장되었던 예외가 다시 발생합니다.

---

### 5. 작업은 어디서 실행되는가?: 실행 컨텍스트 🌐

TAP는 비동기 작업을 `Task`로 **표현**할 뿐, 작업이 **어디서** 실행될지는 지정하지 않습니다. 개발자는 상황에 맞게 선택할 수 있습니다.

* **스레드 풀** : CPU 집약적인 계산 작업.
* **비동기 I/O** : 스레드를 전혀 사용하지 않고 OS 수준에서 처리하는 네트워크 또는 파일 작업 (가장 효율적).
* **특정 스레드** : UI 업데이트 등 특정 컨텍스트가 필요한 작업.

이처럼 구현은 숨기고 `Task`라는 표준화된 객체만 노출하므로, 호출자는 내부 동작을 몰라도 쉽게 비동기 작업을 사용할 수 있습니다.

---

### 6. Task의 생애 주기: Hot vs Cold 🔥❄️

`Task`에는 `Created`(생성됨), `Running`(실행 중), `RanToCompletion`(완료), `Faulted`(오류), `Canceled`(취소) 등의 상태(`TaskStatus`)가 있습니다.

* **Hot Task (뜨거운 작업)** : 호출 즉시 이미 실행이 시작된 `Task`입니다. `async` 메서드나 `Task.Run`이 반환하는 `Task`는 모두 Hot Task입니다.
* **Cold Task (차가운 작업)** : `new Task(...)`로 생성되어 `Start()` 메서드를 호출하기 전까지 실행되지 않는 `Task`입니다.

 **중요 규칙** : **TAP 메서드는 반드시 Hot Task를 반환해야 합니다.** 호출자가 `Task`를 받고 직접 `Start()`를 호출하게 만들어서는 안 됩니다.

---

### 7. 취소: 비동기 작업 포기하기 ⏹️

사용자가 중지 버튼을 누르는 등 작업을 중단해야 할 때 취소 기능을 사용합니다.

* **구현** : `CancellationToken` 매개변수를 추가하고, 작업 중간중간 `cancellationToken.IsCancellationRequested`를 확인하거나 `ThrowIfCancellationRequested()`를 호출합니다.
* **신호** : 취소 요청이 감지되면 `OperationCanceledException`을 던집니다. `async` 메서드는 이 예외를 감지하여 `Task`를 `Faulted`가 아닌 `Canceled` 상태로 만듭니다.
* **사용** : 호출자는 `CancellationTokenSource`를 만들어 `Token`을 전달하고, 원할 때 `.Cancel()`을 호출합니다. 취소된 작업은 `await` 시 `OperationCanceledException`을 발생시키므로 `try-catch`로 처리할 수 있습니다.

---

### 8. 진행률 보고: 얼마나 진행됐나요? 📊

파일 다운로드처럼 오래 걸리는 작업의 진행률을 보고할 때는 `IProgress<T>` 인터페이스를 사용합니다.

* **구현** : `IProgress<T>` 타입의 매개변수를 추가하고, 진행 상황이 업데이트될 때마다 `progress.Report(value)`를 호출합니다.
* **사용** : 호출자는 `Progress<T>` 클래스 인스턴스를 만들어 전달합니다. 이 클래스는 UI 스레드와 같은 원래 컨텍스트로 진행률 업데이트를 안전하게 전달해주는 역할을 자동으로 처리합니다.

---

### 9. 오버로드 설계: 취소와 진행률의 조합 🎨

취소와 진행률을 모두 지원하면 메서드 오버로드가 많아질 수 있습니다. 일반적인 해결책은 두 가지 버전만 제공하는 것입니다.

1. **기본 버전** : 필수 매개변수만 있는 가장 간단한 메서드.
2. **전체 버전** : 필수 매개변수와 함께 `CancellationToken` 및 `IProgress<T>`를 모두 포함하는 메서드.

사용자는 필요 없을 경우 전체 버전을 호출하며 `CancellationToken.None`이나 `null`을 전달하면 되므로, API를 깔끔하게 유지할 수 있습니다.
