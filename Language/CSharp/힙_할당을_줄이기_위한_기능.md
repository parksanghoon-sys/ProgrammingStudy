# Heap 할당을 줄이기 위한기능

## Struct 사용

C#의 클래스는 참조형이므로 클래서의 인스턴스를 많이 생성 시 GC에 부담이 걸린다, 반면 구조체는 스택이나 클래스/배열 안에 직접 인스턴스를 확보할 수 있다.

System.Numberics 네임스페이스에는 이를 이용한 복소수형 Complex 나 3D Vector3등이 미리 구조체로 정의 되어 있다, 물론 int, float타입 등도 구조체의 일종으로 되어 있다.

## 함수에 ref, out 으로 전달

C++ 의 포인터나 참조를 사용하는 용도 중의 하나는, 함수로부터 복수의 값을 돌려주는 것이다, C# 은 힙 할당 없이 함수로 부터 복수의 값을 돌려줄 수 있다.

함수나 클래스의 파라미터가 [입출력 겸용]이라면 *ref*, [출력 전용] *out* 을 사용한다, 함수로 부터 복수의 값을 돌려주기 위해선 구조체나 튜플을 사용 할 수도 있다. 또한 구조체에 대한 반환 값으로 반환할때 복사 오버헤드를 줄이는데 사용이 가능하다.

## 값 유형 튜플 사용 (C# 7.0 이상)

구조체를 정의할 정도는 아니지만 몇가지 쌍의 값을 사용하고싶은 경우 튜플을 사용할 수 있다.

예를들면 (double, int)라는 형식은 struct System.ValueTuple<double, int>의 별칭으로 double 값과 int 값 형식으로 유지할 수 있다.

## 함수에 in 으로 전달(C# 7.2 이상)

C++의 포인터나 참조의 용도 중의 하나로, 예를 들면 입력전용으로, 큰 클래스나 구조체를 복사하지 않고 건네준다는 것이 있다.

C#에서는 큰 구조체를 in으로 함수에 참조로 전달이 가능하다. 이것은 c++ const참조와 유사하다, ref 와 out 과 달리 in으로 전달된 구조체의 내용은 변경할 수 없으므로 호출자에서 in키워드를 붙일 필요가 없다.

## 제네릭스 사용

값 타입의 인스턴스를 object타입 똔는 interface 타입으로 변환하면 박싱이 발생한다, c#의 제네릭스는 Java와 달리 박싱을 최대한 회피할 수 있도록 설계되었다. 이것은 List `<int>값은 기본적인 사용법은 물론, 인터페이스 제약이 있는 경우에도 박싱 없이 가능하다 예를들면`

```csharp
class Container<T> where T : IComparable<T>
{
	// IComparable<T>.CompareTo를 이용한 무언가
}
```

위와같은 타입이 있을  시 이 T 에

```csharp
struct Node : IComparable<Node>
{
	public int CompateTo(Node other) => // ...
}
```

라는 구조체 타입을 대입하여 Container `<Node>라는 타입을 만들어 사용 시 박싱은 발생하지 않는다. 이것은 인터페이스가 [제약`] 으로서만 기능하고, 실제로 인터페이스 타입으로 캐스트 되는것은 아니기 때문이다. 구조체는 상속 할 수없기 때문에, 인터페이스 메소드의 호출처는 T에 Node를 대입한 시점에서 정해진다.

***따라서 런타임은 인터페이스 메서드 호출을 정적 호출로 바꿀수 있다***

## Span `<T>` 사용

작은 배열이라면 stackalloc을 사용하여 스택에 넣어 사용할 수 있다. 이전에는 stakalloc을 사용 시 unsafe 코드 내에서 포인터를 사용해야 했지만 이젠 Span 으로 사용한다

Sapn `<T>` 타입은 통상의 매니지드 배열 또는 그 부분열, 스택상의 배열, 비매니지드 협상의 메모리 블록을 통일적으로 표현할 수 있는 구조체로 이것을 사용하는 것으로 C++ 에서 선두포인터와 배열의 길이를 지정하는것 같은 유연성을 얻을 수 있따.

더불어 Span `<T>` 는 List `<T>` 에서도 생성할 수 있지만, 내부에서 배열의 재확보가 발생하면 무효한 배열을 가리키는 상태가 되기 때문에 System.Runtime.InteropServices.CollectionsMarshal 클래스에 숨겨져 있다.

### 덤 : 포인터 사용

C#은 안전과 실행 속도의 균형을 이루는 언어이며 실행 속도는 가능한 한 추구하지만 최우선 사항은 아니다. 하지만 unsafe 선언된 블록 내에서 포인터를 사용할 수 있다. C++가 그렇듯이, 부주의한 포인터의 사용은 복잡하고 괴기한 버그를 발생시킬 가능성이 있으므로, 이 옵션은 마지막 수단으로 해 두는 것이 좋다. 원리적으로는, 포인터를 사용하면 값 타입만으로 참조 같은 것은 모두 할 수 있을 것이다.
