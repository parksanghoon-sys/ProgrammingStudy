## 컨텍스트 (context)

프로세스를 실행하기 위한 여러가지 정보들, 이러한 정보는 PCB에 저장이 된다.

## Context Switching(컨텍스트 스위칭)

* 실행할 프로세스를 교체하기 위해 언급했던 컨텍스트를 교체하는 행위이다
* 컨텍스트 스위칭은 OS 커널단에서 실행이 된다.

### 컨텍스트 스위칭 동작

스레드 A에서 스레드 B로 전환된때 발생 된다. 이때 스레드 A, 스레드 B가 속해 있는 프로세스가 같으면 스레드 컨텍스트 스위칭이 처리가 되고, 프로세스가 다르면 프로세스 컨텍스트 스위칭 처리로 몇가지 작업이 추가로 진행 된다.

1. 현재 실행 중인 프로세스 정보를 PCB에 업데이트 후 메모리에 저장
2. 교체할 프로세스 정보를 메모리에서 가져와 PCB에 넣고 실행한다.
3. 상황에 따라 CPU 캐시를 비운다. (flush) -> 프로세스 컨텍스트 스위칭 행위시 추가
4. TLB (Table Lockaside Buffer)을 비운다. -> 프로세스 컨텍스트 스위칭 행위시 추가
5. MMU(Memory Management Unit)을 변경한다.  -> 프로세스 컨텍스트 스위칭 행위시 추가

## 메모리 베리어(Memory Barrier)

멀티 스레딩 환경에서 데이터의 일관성과 순서를 보장하기 위한 매커니즘이다.

CPU의 성능을 위해 컴파일러는 최적화를 통해 의도한 본질의 코드 순서와 맞지 않게 실행되어 예상치 못한 결과가 나올 수 있다.

이러한 문제를 해결하기 위해 컴파일러에 barrier 명령문 전 후의 메모리 연산을 순서에 맞게 실행하도록 강제한다. 즉. barrier 이전에 나온 연산은 barrier 이후에 나온 연산보다 먼저 실행 되도록 보장한다.

## 동기화

스레드 동기화는 *다수의 스레드가 공유 데이터에 동시에 접근* 하려는 경우 데이터가 손상되는것을 방지하기 위해 사용된다.

도익화는 크게 3가지의 문제가 있다.

1. 여러 스레드들이 접근할 가능성이 있는 데이터가 어떤 것인지 확인 후 스레드 동기화 락을 획득하고 해재하는 코드를 이요하여 데이터 접근 부분을 감싸야 한다, 이런 처리가 정상으로 동작되는지 확인 방법은 응용프로그램을 수행하고, 스트레스 테스트를 여러 번에 걸쳐 수행해야한다
2. 성능을 해친다, 락을 획득하고 해재하는 과정은 추가적인 함수 호출을 수반하고 CPU가 여러 스레드들 중 어떤 스레드가 처음으로 락을 획득하도록 할 것인지 결정해야 하는데 이러는 과정은 상당한 시간을 소요하게 된다
3. 블로킹 될때 새로운 스레드가 생성되고 다시 블로킹 되었던 스레드가 수행을 재개하는 경우 새로 생성딘 스레드와 함께 스케줄링 되어야하는데 이런 상황은 컨텍스트 스위칭이 발생하게 되어 선능에 나쁜 영향을 주게 된다,

## 스레드 안정성

닷넷 코어 이상의 FCL은 모든 정적 메서드에 대해 스레드-안정성을 보장한다.

메스드를 스레드-안정적을 만든다는것은 반드시 동기화 락을 사용함을 의미하지는 않는다.

만약 값타입을 파라미터로 받는 정적인 메서드를 만든다면 값타입을 받기때문에 복사본이 전달되어 여러 스레드에서 동시에 호출해도 각 스레드에 별개로 고유의 데이터를 가지고 작업을 수행하게 된다.

하지만 참조타입의 메서드의 경우 여러 스레드가 동시에 호출 하는 경우 스레드에 안전하지 않는다.

## 동기화 요소

* 단순 도익화
  * 유저모드 동기화, 커널모드 동기화가 있다.
* 복합 스레드 동기화
  * 단순 동기화 요소에 해당하는 '유저모드 동기화, 커널모드 동기화' 를 결합하여 만드는 형식이다

### 유저모드 동기화

유저모드의 동기화는 특수한 CPU 명령을 사용해서 하드웨어적으로 동기화를 사용하는 것이다.

그래서 커널모드 동기화에 비해 훨씬 빠르게 수행된거 커널에서 스레드가 블로킹 되었는지 알지 못하기 때문에 새로 스레드를 생성하지 않는다.

C#에서 유저 모드 동기화 종류는 아래와 같다

* Monitor 클래스 (lock 키워드)
* volatile 키워드
  * 원자적으로 변수의 값을 읽고 쓸수 있게해준다.
  * 메모리 베리어에 의한 컴파일러 최적화를 피해 사용이 가능하다.
* Interlocked 클래스

유저모드 동기화는 커널에서 알 수 없기 때문에 스레드가 락 획득을 위해 리소스를 반복적으로 요구할 경우 *CPU 시간을 낭비* 할수 있다.

반면 커널 모드 동기화는 OS가 자체적으로 제공하기 떄문에 블로킹의 스레드는 CPU 시간을 더이상 낭비 하지 않도록 스레드를 중단 시킬 수 있다.

따라서 **커널모드 동기화는 응용프로그램의 스레드가 운영체제의 커널이 구현하고 있는 함수를 호출**해서 동기화 요소를 사용하고 **유저모드 에서 커널 모드로의 전환이 이루어져 상당한 성능 저하**를 일이킨다.

### 유저모드 동기화 요소

CLR은 boolean, char Byte, int, inptr, single, 참조타입의 변수에 대해서 **원자적** 으로 값을 읽고 쓸수 있음을 보장한다.


### 커널 모드 동기화 요소

윈도우 운영체제는 스레드 동기화를 위한 요소를 제공한다, 커널모드 동기화요소는 유저모드 동기화 요소에 비해 상당히 느린 편이다.

그 이유는, **커널모드 동기화 요소들이 운영체제에게 스레드간의 동기화 요청** 하는 것이기 때문이다, 그리고 각각의 메서드들은 커널 객체를 이용하고 그로인해 스레드가 **관리코드에서 네이티브 사용자 코드를 거쳐 네이티브 커널모드코드까지 전환** 되었다가 다시 역순으로 반복하게 되기 때문이다.

C#에서 커널모드 동기화의 종류는 아래와같다

* Mutex
* Semaphore
* 이벤트
  * AutoResetEvent
  * ManualResetEvent
  * ConuntdownEvent

### CAS(Compare and Swap) Algorithm

CAS 알고리즘은 락기능을 구현하기 위해 만든 비교와 교환 연산이 합쳐진 연산 알고리즙이다

```csharp
int compareAndSWap(ref int var, int newVal, int excepedVal)
{
	int curVal = var;
	if(var == exceptedVal)
	{
		var = newVal;
	}
	return curVar;
}
```

이때 핵심은 값을 변경하는 시점에 변경할 변수가 기대하는 값과 같은면 새로운 값으로 교체하는것이다

또한 lock처리로 인한 Blocking이 없다, 이를 활용하여 다른 스레드를 Block 시키지 않고 동기화를 구현 할 수있다.

### ABA Problem

CAS 를 사용하는 Lock-free 알고리즘의 고질적인 문제가 있는데, 공유 객체의 변경을 감지하지 못하는 현상을 말하는데 CAS 연산에 메모리 주소 혹은 레퍼런스를 사용할 때 메모리가 재사용하는 경우에 발생한다.,
