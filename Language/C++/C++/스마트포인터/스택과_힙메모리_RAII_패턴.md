# 스택과 힙 메모리

![memory](/Language/C%2B%2B/C%2B%2B/Images/%EC%8A%A4%ED%83%9D%EA%B3%BC_%ED%9E%99%EB%A9%94%EB%AA%A8%EB%A6%AC.png)

## 스텍메모리
---
스택은 *지역변수*와 *매개변수*가 저정되는 공간이며 예약된 지역 메모리이다. 동적으로 할당되는 힙메모리와 달리 메모리 할당과 해재에 대한 오버헤드가 없다.  
데이터 저장 시 가장 높은 주소 부터 거꾸로 저장이 된다, 즉 스택의 top은 가장 낮은 주소이다.
### **스택 프레임**
 호출과 반환이 스택 메모리에서 일어나며 함수를 호출 시 "스택 프레임"이 쌓인다. 하나의 호출된 함수가 사용되는 영역이다. main도 함수이며 그외의 다른 method들도 함꼐 쌓인다.(main은 가장아래 쌓여있다.)  
 지역변수, 매개변수, 함수동작을 마치고 호출한 영역으로 복귀할주소, 자신을 호출한 함수를 계속해서 실행하기위한 그 함수의 프레임 주소도 등등이 들어가있다. 재귀 호출의 경우 연속적으로 너무 많이 실행될시 스택의 영역의 메모리 를 overflow해 조심해야한다.
  
  ![memoryStack](/Language/C%2B%2B/C%2B%2B/Images/%EB%A9%94%EB%AA%A8%EB%A6%AC%20%EC%8A%A4%ED%83%9D%EC%9D%98%20%EA%B5%AC%EC%A1%B0.png)
  스택은 데이터를 push & pop 할때 스택 포인터(SP)를 단순히 위 아래로 이동 함으로써 스택을 동작한다.  
  SP는 항상 스택 프레임의 top를 가리킨다, 그리고 베이스 포인터(BP) 라는것은 현재 실행중인 함수의 스택 프레임의 첫 위치를 저장한다. 따라서 BP는 새로운 함수 호출 시 변경되므로 이전 BP를 어딘가 임시로 저장시킨다, 그 값이 위의 sub 스택프레임에 저장된 "callerbase"이며 main 함수의 첫 주소를 가리킨다.
  ### **스택 이 힙보다 빠른이유**
  1. 미리 예약된 메모리기 떄문에 메모리 할당이 필요없이, 사용한 메모리를 반납하지 않고, 스택포인터를 감소시킴으로 스택공간을 확보한다. 떄문에 객체는 속한 영역 (scope)를 벗어날 시 스택 포인터의 위치가 바뀌고 사라진다.
  2. 스택은 컴파일타임에서 이루어져있어 실행중 메모리를 계산하거나 판단할 일이 없기 떄문에

## 힙 메모리
---
동적으로 할당된 메모리가 저장되는 공간이다. 
Stack 과달리 scope 에서서 벗어나도 자동으로 삭제되지 않는다.  

힙메모리는 스택보다 매우느리다. 운영체제게 메모리를 훑으며 할당가능한 연속된 메모리 공간을 찾고 반환을해주어야 하기떄문이다.  

또한 힙 메모리의 재할당이 자주 발생시, 메모리 단편화를 일으킨다. 메모리 단편화란 남아있는 메모리는 충분하지만 연속적인 메모리가 남아있지 않고 띄엄띄엄 있어 배열과 같은 연속된 메모리를 할당해 줄 수 없는 현상이다.  

또한 메모리의 해제또한 속도를 저하시킨다, 메모리 해제시 사용한 메모리를 반환시 기존에 메모리덩어리를 합치는데 이떄 병합작업이 속도를 저하시킨다.  

## RAII(Resource Acquisition Is Initialization)
---
리소스를 자동으로 관리하기 위해 컴퓨터 프로그래밍, 특히 C++ 및 기타 객체 지향 언어에서 사용되는 패턴입니다. RAII에서 리소스 할당 및 할당 해제는 개체의 수명과 연결됩니다. 개체가 생성되면 필요한 리소스를 획득하고 개체가 범위를 벗어나거나 소멸되면 리소스가 자동으로 해제됩니다.  
C++ 11부터는 RAII의 원리가 적용된 스마트 포인터라는 것이 생겼다.