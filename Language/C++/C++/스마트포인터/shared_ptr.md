# 공유 포인터 | std::shared_ptr

## std::shared_ptr

포인터의 소유권을 다른 포인터와 공유할 수 있으며, 참조카운팅 기반으로 동작하는 스마트 포인터이다.  

shared_ptr은 맴버변수로 **원시 포인터를 가리키는 포인터 (_Ptr)1개, 참조 카운팅을 관리하는 포인터 (_Rep)1개**를 가진다. 
* 원시 포인터
  * 메모리 주소를 직접 다루며, 메모리 할당과 해재를 수동으로 해주어야한다.
  * 원시 포인터를 사용 시 자신이 참조하는 객체가 언제 삭제될 지에대해 수동으로 관리해야한다.
  * 예를들어 `new` 키워드를 사용하여 힙에 할당시 `delete`를 사용하여 해재한다.
  * \<T> 에 함유된 그자체 라고 볼수 있다.
  * 해당 객체의 수명은 참조 카운터가 관리.
* 참조 카운터
  * 객체에 대한 참조를 갖는 포인터, 사옹 시 자신이 참조하는 객체가 솔멸시 소멸된다.
  * 다른 포인터 변수와 달리, 객체의 주소를 변경이 불가능하다, 한번 참조시 다른 객체를 참조할 수 없다.
  * 예를들면 `&` 해당 연산자를 사용해 선언한다.
  * ```c++
      shared_ptr<int> p1 = make_shared<int>(10);
      // 참조 카운터 1로 설정
      shared_ptr<int> p2 = p1; // 참조 카운트 2
      p1.reset(); // 참조 카운트 1
      p2.reset(); // 참조 카운트 0 -> 객체 삭제됨
      ```


원리는 먼저 내부적으로 자신에게 바인딩 된 원시 포인터에 참조카운터를 1증가한다, strong ref(강한참조)가 참조 카운터이다. 
### **shared_ptr 개체 생성**
std::make_shared 함수를 통해 공유 포인터 개체를 생성한다.
```c++
class Foo
{
public:
   Foo(const char* name, unsigned int age) {}
   void DoSomething();
   ...
};

void MakeUniqueExample()
{
   std::shared_ptr<Foo> f = std::make_shared<Foo>("foo", 14);
   std::shared_ptr<Foo> f2(new Foo("woohyen",5));
   f->DoSomthing(); // f가 소유한 원시 포인터의 멤버에 접근
   f.reset();       // 공유 포인터의 멤버 함수 
}
```
### **원시 포인터 공유**
원시 포인터의 복사의 경우 깊은 복사가 아닌 얕은 복사를 한다.
```c++
void SharedPtrExample()
{
   std::shared_ptr<int> s1 = std::make_shared<int>(10);
   std::shared_ptr<int> s2 = s1;
   ...
}
```
여기서 s2는 s1에 바인된 포인터를 가리키는데, 해동 포인터를 개체가 늘었으모로 참조 카운터는 1증가된다.
### **함수의 인자로 공유 포인터 전달**
* 값 현식으로 전달
  * 인자를 call by value로 전달시 참조카운터가 증가된다, 
  * 복사 생성자에 단 오버헤드와 참조 카운트조작에 대한 오버해드가 있따.
* 참조 형싱으로의 전달
  * 값 복사가 일어나지 않으므로 참조카운터는 증가하지 않는다.

### **멀티 스레드 환경에서의 문제점**
이는 참조 카운트 방식에서의 문제점이지만 shared_ptr에선 해결이 된다.

참조 카운트는 메모리가 참조될 때마다 참조 카운트를 증가시키고, 참조되지 않을 때마다 감소시킨다. 이는 멀티 스레드 환경에서 문제가 될 수 있다. 예를 들어 현재 참조 카운트가 1인 메모리 M을 스레드 A가 참조하려고 참조 카운트를 1 증가시키려고 한다. 그런데 스레드 B 또한 M을 참조하기 위해 참조 카운트를 1 증가시키려고 한다. 그런데 스레드 A, B 모두 M의 참조 카운트가 1일 때 가져가버렸다. 정상적인 경우라면 카운트는 2 증가하여야 하는데, 두 스레드 모두 1에서 증가시켜 2가 되었다.

이는 멀티 스레드 환경에서 발생할 수 있는 race condtion(경쟁 상태)라는 상태이며 lock 또는 mutex와 같은 함수를 통해 두개 이상의 스레드가 동시에 접근하지 못하도록 막아야 하는데, 이 경우 속도가 느려지게 된다. shared_ptr는 내부적으로 이 문제점을 해결하여 등장하였으며 최적화가 되어 있다. 멀티 스레드 환경에서 shared_ptr를 사용하지 않을 경우, 참조 카운팅 방식은 기존의 C스타일 포인터보다 느리다. 왜냐면 참조 카운트라는 공유 자원을 사용하기 위해선 lock과 같은 함수가 필요하기 때문이다.