# .NET에서의 인증 — 1부: 소개 및 미들웨어 아키텍처

**인증 vs. 인가**

* 인증(Authentication): 사용자가 누구인지 확인 ("Who are you?")
* 인가(Authorization): 사용자가 무엇을 할 수 있는지 확인 ("What can you do?")
* ASP.NET Core는 이를 별도의 미들웨어로 분리해 유연하게 구성 가능.

**ASP.NET Core 인증 구조**

* 모듈화되고 확장 가능한  **스킴 기반 구조** .
* 각 인증 스킴(예: 쿠키, JWT, OIDC)은 전용 핸들러를 통해 신원 검증 및 클레임 발급.
* 예시: `AddAuthentication`으로 기본 스킴과 챌린지 스킴 설정 후 `AddCookie`, `AddOpenIdConnect`로 구현

```csharp
builder.Services.AddAuthentication(cfg =>
{
    cfg.DefaultScheme = "UserSession";
    cfg.DefaultChallengeScheme = "OidcGateway";
})
.AddCookie("UserSession")
.AddOpenIdConnect("OidcGateway", options =>
{
    // Configure OIDC settings here
});

var app = builder.Build();
app.UseAuthentication();
app.UseAuthorization();
```

**Claims 기반 신원 관리**

* 인증 후 `ClaimsPrincipal` 객체가 생성되어 사용자 정보(예: 이름, 부서, 권한 수준)를 담음.
* 이후 인가 결정은 이 클레임을 기반으로 수행.

```csharp
new Claim(ClaimTypes.NameIdentifier, "alina.wilson@demo.io"),
new Claim("Division", "Finance"),
new Claim("ClearanceLevel", "5")
```

**미들웨어 요청 흐름**

1. 사용자가 보호된 리소스 URL에 접근
2. 미들웨어가 인증 여부를 확인
3. 인증되지 않는다면 로그인 페이지로 리다이렉트
4. 로그인 성공 시 쿠키/토큰 발급
5. `ClaimsPrincipal`이 `HttpContext.User`에 주입
6. 클레임 기반 인가 결정 수행

**왜 중요한가**

* 올바른 인증 전력 선택(쿠키, 토큰, 외부인증)
* 디버깅 용이
* 클레임, 정책 커스텀 핸들러로 확장이 가능
