## HTTP 프로토콜

### 개요

웹 통신의 기반은 인터넷을 통해 정보가 전송 되는 프로토콜 HTTP 에 의존산다.

기본적으로 HTTP는 클라이언트가 서버에 요청을 보내고 서버는 요처된 리소스 똔느 적절한 상태코드를 응답하는 요청-응답 프로토콜로 작동한다. 인터넷을 통해 통신하며 다양한 어플리케이션을 구축한다.

HTTP는 성능 보안 및 확장성을 개선하기위해 , 영구 연결과 청크 전송을 도입한 HTTP/1.1 부터 멀티 플렉싱 및 향상된 헤더 압축과 같은 기능을 도입한 HTTP/2, HTTP/3에 이르기까지 발전하며, 요구사항을 해결했다. 이러한 발전으로 인해 HTTP는 빠르고 안전하며 신뢰할 수 있는 통신이 가장 중요한 시대에도 유지하고 있다.

HTTP의 세부 사항으로는 HTTP 메시지구조, 다양한 HTTP 메서드 역할, 헤더 및 상태코드의 중요성을 살펴본다.

### HTTP Verbs

HTTP 메서드에는 GET, POST, PUT, DELETE가 있지만 HEAD, PATCH 및 OPTIONS 와 같은 추가 메서드가 있으며 각각 고유한 용도로 사용된다.

* GET
  * 서버를 수정하지 않고 서버에 데이터를 검색하도록 설계 되었다.
  * 클라이언트 요청 시 서버는 HTML 페이지, JSON 데이터 또는 다른 형식에 상관없이 리소스로 응답한다.
* POST
  * 새 리소스를 만들기 위해 서버로 데이터를 보내는데 사용
  * 사용자 데이터를 제출하거나 유지되는 변경 작업을 수행하는등 서버 상태를 수정하는 잡업 시 POST가 사용된다.
* PUT, PATCH
  * 기존 리소스를 업데이트 하는 역할을 하지만 범위가 다르다
  * PUT
    * 전체 리소스를 새 데이터로 교체하여 반복하는 요청이 동일한 결과를 생성
  * PATCH
    * 전체 리소스를 서버로 다시 보내지 않고도 업데이트를 허용하므로 대규모 데이터를 세트로 작업할 때 유용하다
* DELETE
  * 서버에서 리소스를 제거하는 역할
* HEAD
  * GET 과 비슷하지만 본문이 아닌 리소스의 헤더만 검색한다
  * 전체 컨텐츠를 다운받지 않고 리소스의 크기, 마지막 수정날짜와 같은 메타데이터를 확인하는데 유용하다.
  * GET 요청전 간단한 검사시 사용된다

### HTTP 헤더

HTTP 헤더는 클라이언트와 서버 간 통신의 중요한 구성 요소이다. 요청 및 응답 프로세스를 관리하는데 도움이 되는 메타 데이터를 제공한다. 헤더가 없을 시 콘텐츠 형식, 인코딩, 인증토큰, 캐싱 규칙 등과 같은 요청 또는 응답에 대한 추가 정보를 전달하는 키- 값 쌍이 포함되어 있으먀 통신 프로세스가 크게 저하된다, HTTP 메시지에 헤더를 포함 시 클라이언트와 서버는 메시지의 핵심 본문을 수정하지 않고 중요 컨텍스트 데이터를 교환이 가능하다.

오청헤더를 사용 시 클라이언트가 기본 설정을 지정하고 서버에 추가 데이터를 요청 할 수있다. 헤더는 인증을 위한 전달자 토큰과 같은 자격증명을 전송하여 요청이 안전하게 처리되도록 한다, 일반적으로 사용되는 또 다른 헤더는 요청이 수행하는 클라이언트 응용 프로그램 또는 브라우저를 식별한다. 이를통해 서버는 친화적인 버젼의 웨사이트를 제공이 가능하다.

서버 쪽에서 응답헤더는 반환된 콘텐츠와 클라이언트가 이를 처리하는 방법에 대한 중요한 세부 정보를 제공한다, 헤더는 클라이언트가 응답을 캐시하는 방법을  제공하며 또한 서버의 부하를 줄이기 위해 데이터를 재사용하도록 권장하거나 만료시간을 설정해 컨텐츠가 항상 최신 사앹로 유지되도록 한다.

보안 관련 헤더는 클라이언트와 서버를 보호하는데 필수 적이다, 예를들면 헤더는 클라이언트에 세션정보를 저장하여 서버가 여러 초엉에 사용자 상태를 유지할 수 있도록 한다, 보안연결을 보장하기위해 HTTPS의 사용을 적용한다,

HTTP 헤더의 효과적인 사용은 기술적 구현에관한게 아니라 웹의 견고성과 보안을 향상시키는 것이다. 헤더를 구성하고 관리한다면 보다 효율적이고 안전한 시스템을 구축 할 수 있다

### HTTP 상태코드

상태코드는 HTTP 통신의 중요한 부분으로, 요청 결과에 대한 피드백을 클라이언트에 제공한다.

* 1xx
  * 정보응답을 나타낸다.
  * 일반적인 예로는 요청 초기부분이 수신되었으며 클라이언트가 요청 본문의 나머지 부분을 보내야함을 나타낸다.
  * 100 Contiue
* 2xx
  * 성공적인 응답을 나타낸다.
  * 요청이 성공적으로 처리 되었으며, 서버가 요청한 리소스를 반환 했음을 나타낸다.
  * `200 Ok` `201 Create` `204 No Content`
* 3xx
  * 일반적으로 요청을 완료하기 위해 추가 작업을 수행하도록 클라이언트에 지시
  * URL 재구성 또는 도메인 변경에 자주 사용된다.
  * `301 Moved` `302 Found`
* 4xx
  * 요청에 잘못된 구문이 포함되거나 이행할 수 없음을 나타낸다.
  * 클라이언트에게 인증이 필요하다는것을 알려준다.
  * 권한부여를 거부하는 경우 반환
  * `400 Bad Request` `401 Unauthorized` `403 Forbidden` `404 Not Found`
* 5xx
  * 서버가 유효한 요청을 이행하지 못할 때 발생하는 서버 측의 오류를 나타낸다.
  * 게이트웨이 또는 프록시 역할을 하는 서버가 업스트림 서버로부터 잘못된 응답을 받았음을 나타내는, 즉 서버가 과부화로 인해 일시적으로 처리할수 없을 떄 사용된다.
  * `500 Internal Server` `502 Bad Gateway` `503 Service Unabailable`

올바른 HTTP 상태코드를 사용하는것은 클라이언트와 서버간 명확한 통신을 설정하는데 도움이 된다.

### HTTP 메시지 및 데이터 교환

HTTp의 데이터 교환은 일반적으로 요청 또는 응답의 페이로드가 배치되는 메시지 본문을 통해 수행된다. 웹페이지, 이미지, JSON 과 같은 다양한 데이터 형식을 지원하는 HTTP의 유연성은 광범위한 에플리케이션을 구축하는데 유리하다, 예를 들면 POST요청 시 API에 데이터를 제출할 때 클라이언트는 서버가 처리하고 저장하는 요청 본문에 페이로드를 보낸다, 마찬가지로 서버가 클라이언트의 데이터 요청에 응답 시 응답 본문에는 적절한 형식의 리소스가 포함된다.

헤더는 데이터 처리방법을 지정하여 데이터 교환에서 중요한 역할을한다. 이를 통해 개발자는 데이터가 양측이 올바르게 해석할 수 있는 형식으로 교환이 되도록 할 수 있는 통제력과 책임감을 갖는다.

## REST의 애해

REST 는 분산시스템 , 웨서비스를 위해 설계된 아키텍쳐 스타일이다. REST는 메서드 사앹코드 및 헤더와 같은 HTTP의 기본 구성요소를 활요하여 확장 가능한 상태 비저장 방식으로 클라이언트와 서버간의 통신을 용이하게한다. 이러한 제약 조건을 준수함으로써 REST ful 시스템은 다양한 플렛폼과 기술간에 유연한 작용을하고 동시에 효율적인 데이터 교환을 가능하게한다.

REST의 핵심은 네트워크에서 엑세스할 수 있는 모든 데이터 또는 서비스를 나타내는 리소스의 개념이다. 각 리소스는 웹페이지에서 해당 주소역할을 하는 URI로 고유하게 실별된다.

RESTful 시스템의 주요 특징은 클라이언트와 서버간에 상태 비저장 통신이다. 클라이언트에서 서버로서 각 HTTP 요청에는 서버가 처리하는데 필요한 모든 정보를 포함한다. 이는 서버가 요청 간에 세션별 상태를 유지하지 않는다는 것을 의미한다. 이를통해 서버는 상호 작용간에 클라이언트별 데이터를 관리하는 오베헤드 없이 각 요청을 독립적으로 처리할 수 있따. 또한 로드 밸런싱을 수행하고 여러 서버에 걸쳐 요청을 분산하는데 있어 유연성을 높여 시스템이 높은 수요와 변화하는 조건을 효과적으로 처리가 가능한다.

REST의 또 다른 기본 원칙으로는 클라이언트와 서버간의 관심사를 분리하는 것이다. RESTful 아키텍쳐에서 클라이언트는 사용자 인터페이스와 사용자 경험을 간리하고 서버는 리소스와 데이터를 관리한다. 예를 들어 모바일 앱과 웹은 사용자 인터페이스가 달라도 동일한 RESTful API 와 상호 작용이 가능하다.

캐싱은 REST가 성능과 확장성을 개선하기 위해 활용하는 원칙이다, 응답을 캐시할 수 있는지 여부를 표시함으로써 서버는 동일한 리소스에 대한 반복적인 요청의 필요성을 줄인다, HTTP 헤더는 캐싱 동작을 좋아하고 제어하며 클라이언트가 만료되거나 무효화될때 까지 응답을 저장하고 재활용한다, 캐싱을 사용 시 서버의 부하를 줄이고 특히 자주 인덱스 하는 데이터를 처리할 때 응답성을 향상시킬 수 있다.

보안은 RESTful API 설계의 중요한 고려사항이다, REST는 특정 보안 관행을 요구하지 않지만 설정된 HTTP 보안 매커니즘과 원할하게 작둉한다, RESTful API는 일반적으로 OAuth2 또는 JWT 와 같은 토큰 기반 인증 메커니즘을 사용해 클라이언트를 인증하고 권하능ㄹ 부여하여 권한이 있는 사용자만 특정 리소스에 엑세스가 가능하도록 한다.

이러한 원칙과 제약 조건을 준수함으로써 REST는 확장 가능하고 안정적이며 유연한 시스템을 개발할 수 있도록 한다, 상태 비저장, 리소스기반 설계 및 균일한 인터페이스에 대한 강조는 RESTful 서비스가 지나치게 복잡해지지 않고 변화하는 요구사항에 맞게 성장하고 적응할 수 있도록 한다. 이러한 확장성과 안정성은 RESTful 시스템이 수요가 많고 변환하는 조건에서 작동할 수 있는 안전한 기반을 제공하여 보안 의식을 심어준다.

### RESTful 리소스 및 URI

리소스 개념은 클라이언트와 서버가 상호 작용하는 방식의 핵심이다. 리소스는 웹을 통해 엑세스하고 조잘할 수 있는 모든 데이터를 나타낸다.

URI는 RESTful 시스템의 각 리소스를 고유하게 식별한다, 예를들면 URI는 모든 제품의 컬렌션을 참조할 수 있찌만 ID가 123인 특정 제품을 가리킨다 예를들면 `/api/products/123` 이런시긍로 한다

URI의 구조는 불필요한 복잡성을 피하고 명확성과 단순성을 염두하고 설계해야한다. 또한 URI 에서 동사대신 명사를 사용해야한다.

### REST 및 HTTP 메소드

클라이언트와 서버간의 상호 작용은 주로 표준 HTTP 메소드를 통해 촉진된다. 각 메서드는 CRUD 작업에 따라리소스에 대한 특정 작업을 수행하도록 설계되었다. HTTP 모소드를 이러한 작업에 매핑함으로서 RESTful 시스템은 리소스와 상호 작용하는 간단하고 일관된 방법을 제공한다. 각 메서드의 역할과 REST 컨텍스트 내에서 사용되는 방법을 이해하는 것은 직관적이고 효율적인 API를 솔계하는데 필수적이다.

서버에서 GET, POST, PUT, DELTE 등의 리소스를 적절하게 제공한다면 RESTful API가 예측 가능하고 사용하기 쉽게 유지되어 개발 프로세스에 대한 확신을 심어줍니다.

### RESTful API 디자인 모범 사례

RESTful API를 설계할 때 가장 중요한 원칙 중 하나는 **리소스 지향적으로** 유지하는 것입니다.

* *명명 규칙의 일관성*
* *버전 관리*
  * 이전버전에 대한 고객의 의존도를 유지해야한다.
  * `/api/v1/products`
* *오류처리*
  * 상태코드를 적절하게 응답해주어야한다
* *페이지 매김 및 필터링*
  * 대규모 리소스 컬렉션을 처리할떄 필수적이다.
  * 예를들어 응답은 페이지당 10개의 항목이 있는 제품의 두번째 페이지를 반환하지 않느다.
  * `/api/products?page=2&size=10``/api/products?category=electronics&sort=price`
* 캐싱
  * API 성능을 향상시키기 위한 기술
  * 서버의 부하를 줄이고, 응답시간 개선, 클라이언트의 더 나은 경험을 제공한다.
* 보안
  * API 설계에서 타협 불가한 측면이다
  * API는 전송중 데이터 암호화를 보장하며 민감한 정보가 가로체지 않도록 항상 HTTPS를 통해 제공되어야한다
  * OAuth2 또는 JWT와 같은 인증 및 권한 부여 메커니즘을 구현하여 중요한 리소스에 대한 엑세스를 제한해야한다.
* 문서
  * Swagger 또는 OpenAPI 같은 도구를 통해 문서화하여 클라이언트에게 보다 알기 쉽도록 해야한다.
* 속도제한
  * 공용 API 경우 속도제한을 구현하여 단기간 너무 많은 요청으로 인해 서버가 문제되는것을 방지하며 시스템이 모든 사용자에 대한 응답성을 유지한다
  * 예를들면 분당 최대 100개의 요청을허용할 수 있으며 그후에는 상태코드를 반환한다.

**확장성** 을 염두하고 설계하는 게 중요하다. 성능저하 없이 증가된 트레픽 및 데이터 로드를 처리할 수있어야한다.

부하분산을 하기위해 서버를 추가하는 수평적 확장과 시스템의 다른 부분을 분리하기 위해 마이크로서비스를 구현하는 것과 같은 기술은 확정성을 달성하기 위한 일반적인 전략이다. 또한 로드 밸런서, 자동 크기조정 및 콘텐츠 전송 네트워크 와 같은 클라우드 서비스를 사용하면 성능과 가용성을 최적화에 도움이된다.
