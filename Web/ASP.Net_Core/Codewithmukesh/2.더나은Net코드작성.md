# NET 개발자의 10+ .NET 팁

## 1. 기초 마스터

복잡한 프레임워크와 디자인 패턴에 뛰어들기전 기본 사항을 잘 이해하는 것이 중요하다.

* 제네릭, 대리자, 비동기/대기, LINQ 및 패턴 일치와 같은 C# 언어 기능.
* SOLID, 상속, 다형성 및 캡슐화를 포함한 객체 지향 프로그래밍 원칙.
* 종속성 주입, 요청 파이프라인, 미들웨어, 구성 관리, 최소 API 등과 같은 .NET 8+ 필수 요소!
* 목록, 사전, 트리 및 정렬 기술을 다루는 데이터 구조 및 알고리즘.
* 예외 관리 및 Visual Studio 도구를 사용한 효과적인 오류 처리 및 디버깅.

## 2. 클린 코드 원칙 따르기

깔끔하고 유지관리 가능한 코드를 작성하는 것은 단순히 작업을 수행하는 것이 아니라 읽기 쉽고, 이해하고 확장 할 수 있도록 하는것이다,

핵심 원칙은 단일 책임 원칙이다, 방법은 한가지 일을 하고 잘해야한다, 대규모 다목적 메서드는 디버깅 및 유지관리가 어려어진다, 긴 메서드를 작성하는 대신 작고 재사용이 가능한 함수로 나누자

또한 의미있는 이름 지정이 중요하다, 변수, 메서드 및 클래스의 이름은 목적을 명확하게 표현해야한다, 메서드가 수행하는 작업을 설명하기위해 주석을 추가하는경우 해당 이름이 충분히 설명이 불가능하다.

## 3. 종속성 주입 이해

DI는 NET에서 가장 강력한 기능 중 하나지만 과소하거나 요용한다, 기본적으로 DI는 종속성을 효율적으로 관리하여 테스트 용이성, 유연성 및 유지관리성을 향상 시킨다, DI를 사용하면 종속송을 하드코딩 하는 대신 필요한곳에 종속성을 삽입하여 구성요소 간의 긴밀한 결합을 줄일 수 있다.

개발자가 저지르는 실수 중 하나는 클래스내에서 종속성을 직접 인스턴스화 하는 것이다, 이로 인해 코드가 엄격해지고 테스트가 어려워진다.

인스턴스를 직접 생성한다면 해당 서비스를 변경해야하는경우 해당하는 클래스를 수정해야하느며 이는 개방/폐쇠 원칙을 위반하게된다. DI를 통해 인터페이스르 이용하여 설계를 한다면 유연하고 쉽게 테스트가 용이하다,

## 4. 비동기식 프로그래밍을 현명하게 사용

.NET의 비동기 프로그래밍은 응용 프로그램의 응답성과 확장성을 향상시키는 데 도움이 됩니다. 그러나 이를 오용한다면 성능 병목현상, 교착상태 또는 과도한 스레드 사용이 발생할 수 있다, 비동기 프로그래밍을 언제 어떻게 사용하는지 아는것이 중요하다.

개발자는 비동기코드를 차단하여 실수할 수있는데 이를 조심해야한다. 그래야 비동기식으로 유지되어 완룔를 기다리는동안 스레드를 다른곳에서 사용이 가능하다.

#### 필요하지 않은 경우 비동기 오베헤드 방지

모든 메서드가 비동기적일 필요는 없다, 작업이 CPU 바인딩이고 I/O를 포함하지 않는경우 비동기로 설정하면 불필요한 오버헤드가 발생 할 수있다.

#### 라이브러리에서 ConfigureAwait(false) 사용

라이브러리 코드를 작성할 때 호출 컨텍스트를 캡처하지 않도록 하여 UI가 아닌 애플리케이션의 성능을 향상시킬 수 있습니다.

```csharp
public async Task<string> FetchData()
{
    await Task.Delay(1000).ConfigureAwait(false);
    return "Data loaded";
}

```

비동기 프로그래밍은 강력한 도구이지만 현명하게 사용해야 합니다. 호출 차단을 피하고, CPU 바인딩 코드를 동기 상태로 유지하고, 불필요한 비동기 오버헤드에 유의하세요. 비동기 프로그래밍을 올바르게 사용하면 더 빠르고 확장 가능한 애플리케이션이 만들어집니다

## 5. 중요한 모든것을 기록하라

로깅은 신뢰할 수 있는 애플리케이션을 구축하고 유지 관리하는 데 있어 가장 중요한 측면 중 하나입니다. 특히 프로덕션 환경에서 문제를 디버깅, 모니터링 및 진단하는 데 도움이 됩니다. 그러나 과도한 로깅 또는 잘못된 정보 로깅은 로그가 전혀 없는 것만큼 해로울 수 있습니다.

일반적인 실수는 **정보** 수준에서 모든 것을 기록하여 심각한 오류를 놓치면서 불필요한 세부 정보로 로그 파일을 넘치게 하는 것입니다. 또 다른 실수는 보안 위험을 초래할 수 있는 민감한 데이터를 기록하는 것입니다.

좋은 로깅 전략에는 다음이 포함됩니다.

* 적절한 수준의 로깅:
  * 개발에 유용한 심층적인 통찰력을 위한 **디버그**
  * 일반적인 신청 흐름에 대한 **안내**
  * 주의가 필요한 잠재적인 문제에 대한 **경고**
  * 즉각적인 조치가 필요한 오류에 대한 **오류**
  * 시스템 중단 문제에 **중요**
* 문제를 더 빨리 진단하는 데 도움이 되는 컨텍스트 정보를 포함합니다. 예를 들어, 오류 메시지만 기록하는 대신 관련 요청 세부사항, 사용자 ID 또는 상관 관계 ID를 기록하십시오.

## 6. Entity Framework Core를 수용하되 현명하게 사용하세요.

EF Core(Entity Framework Core)는 .NET 애플리케이션의 데이터베이스 액세스를 간소화하여 원시 SQL 및 상용구 코드의 필요성을 줄입니다. 그러나 내부적으로 어떻게 작동하는지 이해하지 못한 채 맹목적으로 의존하면 성능 문제가 발생할 수 있습니다.

개발자가 저지르는 가장 흔한 실수 중 하나는 **쿼리를 최적화하지 않는 것입니다.** EF Core는 지연 로드 및 자동 변경 내용 추적과 같은 강력한 기능을 제공하지만 잘못 사용하면 불필요한 데이터베이스 적중이 발생할 수 있습니다.

또 다른 실수는 **지연 로딩을 과도하게 사용하는** 것인데, 이로 인해 "N+1 쿼리 문제"가 발생할 수 있습니다. 이는 EF Core가 단일 쿼리에서 가져오는 대신 관련 엔터티를 하나씩 로드할 때 발생합니다.

#### 대규모 데이터 세트 페이지 매김

대규모 데이터 세트를 한 번에 가져오면 애플리케이션 속도가 느려지고 메모리가 고갈될 수 있습니다. 및 와 함께 페이지 매김을 사용하여 데이터를 청크로 로드합니다.`Skip()``Take()`

#### 변경 내용 추적에 유의하세요

**읽기 전용 쿼리에서 성능 향상을 위해 AsNoTracking 사용**

```csharp
var users = await _context.Users.AsNoTracking().ToListAsync();
```

이렇게 하면 EF Core가 변경 내용을 추적하여 메모리 사용량을 줄이고 쿼리 속도를 향상시킬 수 있다.

## 7. 취소 토큰은 중요합니다.

.NET 애플리케이션, 특히 장기 실행 작업을 처리하는 애플리케이션에서 **취소 토큰은** 응답성, 효율성 및 리소스 관리를 개선하는 데 중요한 역할을 합니다. 적절한 취소 처리가 없으면 애플리케이션이 불필요한 작업을 계속 실행하여 CPU 주기 낭비, 메모리 누수 또는 과부하 시 성능 저하로 이어질 수 있습니다.

### 취소 토큰이 중요한 이유는 무엇입니까?

1. **효율적인 자원 활용**
   * 더 이상 필요하지 않은 장기 실행 작업은 즉시 중지해야 합니다. 취소 토큰을 사용하면 불필요한 CPU 및 메모리를 소비하지 않고 이러한 작업을 정상적으로 종료할 수 있습니다.
2. **더 나은 사용자 경험**
   * 웹 애플리케이션에서 사용자가 작업(예: 파일 업로드 또는 API 요청)을 탐색하거나 취소하는 경우 백엔드는 이를 존중하고 불필요하게 계속하는 대신 처리를 중지해야 합니다.
3. **성능 병목 현상 방지**
   * 취소하지 않으면 백그라운드 작업이 쌓이고 시스템 속도가 느려질 수 있습니다. 취소를 적절하게 처리하면 애플리케이션이 불필요한 작업으로 과부하되지 않습니다.
4. **정상적인 종료 처리**
   * 애플리케이션이 종료될 때 백그라운드 작업은 강제로 종료되는 대신 정상적으로 중지되어야 합니다. 취소 토큰은 이를 수행하는 구조화된 방법을 제공합니다.

### 예: API에서 취소 토큰 사용

ASP.NET Core로 작업할 때 프레임워크는 API 엔드포인트에 대한 취소 토큰을 자동으로 제공합니다. 적절한 요청 종료를 보장하기 위해 항상 **비동기 메서드에 전달**해야 합니다.

**잘못된 예(취소 무시)**

```csharp
[HttpGet("long-task")]publicasyncTask<IActionResult> LongRunningTask(){await Task.Delay(5000); // Simulating long taskreturnOk("Task Completed");}
```

여기서 사용자가 요청을 취소해도 서버는 여전히 **전체 5초 지연**을 처리하여 리소스를 낭비합니다. 실제 시나리오에서는 비용이 많이 드는 데이터베이스 쿼리가 될 수도 있습니다.

**더 나은 예(취소 토큰 사용)**

```csharp
[HttpGet("long-task")]publicasyncTask<IActionResult> LongRunningTask(CancellationToken cancellationToken){try{await Task.Delay(5000, cancellationToken); // Task can be canceledreturnOk("Task Completed");}catch (TaskCanceledException){returnStatusCode(499, "Client closed request"); // 499 is a common status for client cancellations}}
```

여기서 클라이언트가 요청을 취소하면 가 throw되고 작업이 즉시 중지됩니다.`Task.Delay``TaskCanceledException`

### 예: 데이터베이스 쿼리에 취소 토큰 전달

**Entity Framework Core**를 사용하여 데이터베이스 쿼리를 실행하는 경우 항상 취소 토큰을 전달합니다.

```csharp
varusers = await _context.Users.Where(u => u.IsActive).ToListAsync(cancellationToken);
```

이렇게 하면 요청이 취소되면 데이터베이스 쿼리도 실행을 중지하여 데이터베이스에 불필요한 부하가 가해지는 것을 방지할 수 있습니다.

### 백그라운드 작업에서 취소 처리

작업자 서비스 또는 호스팅된 서비스에서 백그라운드 작업을 실행할 때 취소 토큰은 애플리케이션이 종료될 때 정상적으로 중지되도록 합니다.

```csharp
protectedoverrideasyncTaskExecuteAsync(CancellationToken stoppingToken){while (!stoppingToken.IsCancellationRequested){await DoWorkAsync(stoppingToken);await Task.Delay(1000, stoppingToken);}}
```

여기서 루프는 무기한 계속되는 대신 정상적으로 종료하는지 확인합니다.`stoppingToken.IsCancellationRequested`

취소 토큰을 적절하게 사용하면 .NET 애플리케이션에서 **성능 향상, 사용자 경험 향상 및 리소스 관리 효율성이 향상**됩니다.

## 8. 성능 최적화(Dapper 사용)

데이터베이스 성능 최적화는 단순히 효율적인 쿼리를 작성하는 것을 넘어 인덱스를 설계하고, 데이터를 올바르게 구조화하고, 병목 현상을 최소화하는 것을 포함합니다. Dapper는 SQL 쿼리를 더 잘 제어할 수 있는 마이크로 ORM이지만 고성능을 달성하려면 데이터베이스 최적화가 여전히 중요합니다.

#### 적절한 인덱싱 사용

인덱스는 쿼리에서 스캔되는 행 수를 줄여 데이터 검색 속도를 높입니다. 인덱스가 없으면 쿼리는 **전체 테이블 스캔을** 수행하므로 큰 테이블의 경우 매우 느려질 수 있습니다.

#### 캐싱을 통한 불필요한 쿼리 방지

데이터가 자주 변경되지 않는 경우 결과를 캐싱하여 데이터베이스 호출을 줄입니다. 자주 액세스하는 데이터에 **Redis**를 사용하거나 메모리 내 캐싱을 사용합니다.

## 9. RESTful API 모범 사례 배우기

잘 구조화되고 효율적이며 유지 관리 가능한 API를 구축하는 것은 .NET 개발자에게 중요한 기술입니다. 잘못 설계된 API는 성능 문제, 보안 취약성 및 실망스러운 개발자 경험으로 이어질 수 있습니다.

이러한 기본 사항 외에도 명심해야 할 몇 가지 추가 모범 사례는 다음과 같습니다.

* **성능 최적화** – 캐싱, 압축 및 페이지 매김을 사용하여 API 과부하를 방지하고 응답 시간을 개선합니다.
* **속도 제한 구현** – 단일 클라이언트의 과도한 요청을 방지하기 위해 속도 제한을 적용하여 API를 남용으로부터 보호합니다.
* **보안 보장** – HTTPS를 사용하고, 모든 입력의 유효성을 검사하고, 오류 메시지에 민감한 정보를 노출하지 마십시오.
* 오류 응답에 ProblemDetails 사용 – 일반 오류 메시지 대신 더 나은 디버깅을 위해 형식을 사용하여 구조화된 오류 응답을 제공합니다.`ProblemDetails`
* **API 호출 모니터링 및 기록** – 주요 지표, 요청 로그 및 실패율을 캡처하여 문제를 사전에 식별하고 API 성능을 최적화합니다.

API 설계는 단순히 작동시키는 것이 아니라 **확장 가능하고 안전하며 사용하기 쉽게** 만드는 것이다.

## 10. 예외를 정상적으로 처리

예외 처리는 단순히 try-catch 블록에서 코드를 래핑하는것 이상이다, 잘 구조화된 접근 방식을 사용한다면 애프리케이션이 안정적으로 유지되고 의미 있는 오류 메시지를 제공하며 민감한 세부 정보가 노출되지 않는다. 예외처리가 제대로 이루어지지 않을 시 충돌, 성능 문제 및 보안위험이 발생이 가능하다.

개발자가 자주 저지르는것은 적절한 처리없이 모든 예외를 포착하는 것이다.

### 전역 예외 처리 사용

모든 컨트롤에서 예외를 처리하는 대신 미들웨어를 사용하여 전역 예외 처리를 설정한다. 

## 11. 단위 및 통합 테스트 작성

테스트는 안정적이고 유지관리 가능한 애플 구축하는데 필수적이다, 단위테스트는 개별 구성요소 테스트에 중점을 두는 반면, 통합테스트는 시스템의 여러부분이 예상대로 함께 작동하는지 확인한다.

#### 단위 테스트

빠르고 독립적이여야한다, 모의 프레임 워크를 사용하는 대신 손으로 쓴 가짜 또는 스텁 을 만들어 종속성을 격리한다

예시 ) 모의 라이브러리 없이 서비스 테스트

```csharp
public class FakeUserRepository : IUserRepository
{
    public Task<User> GetUser(int id) => Task.FromResult(new User { Id = id, Name = "John" });
}

[Fact]
public async Task GetUser_ReturnsValidUser()
{
    var repository = new FakeUserRepository();
    var service = new UserService(repository);

    var user = await service.GetUser(1);

    Assert.NotNull(user);
    Assert.Equal("John", user.Name);
}
```

#### 통합 테스트

통합테스트는 데이터베이스와 상호 작용하는 API 엔드 포인트와 같은 구성 요소가 함께 작동하는지 확인, ASP.NET Core아용시 실행중인 서버없이 API를 쉽게 테스트가 가능

예시)

```csharp
var client = _factory.CreateClient();
var response = await client.GetAsync("/api/users/1");

Assert.Equal(HttpStatusCode.OK, response.StatusCode);
```


### 주요 내용

* **단위 테스트는** 라이브러리를 모의하는 대신 손으로 쓴 가짜를 사용하여 격리되고 빨라야 합니다
* **통합 테스트는** 서로 다른 구성 요소가 상호 작용하는 방식을 확인합니다.
* CI/CD 파이프라인에서 **테스트를 자동화**하여 문제를 조기에 포착

테스트를 통해  **코드 안정성, 더 쉬운 디버깅 및 장기적인 유지 관리가 보장됩니다** .

---

## 12. 장기 실행 작업에 백그라운드 서비스

장기 실행 또는 예약된 작업의 경우 ASP.NET **Core는 호스팅 서비스를** 제공하고 **Hangfire** 및 **Quartz.NET** 는 고급 작업 예약 기능을 제공합니다. 올바른 도구를 선택하는 것은 사용 사례에 따라 다릅니다.

#### **기본 제공 호스팅 서비스(BackgroundService)**

간단한 백그라운드 작업의 경우 ASP.NET Core에서 구현합니다.

```csharp
public class DataSyncService : BackgroundService
{
    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        while (!stoppingToken.IsCancellationRequested)
        {
            await SyncDataAsync();
            await Task.Delay(TimeSpan.FromMinutes(5), stoppingToken);
        }
    }
}

// program.cs에 등록
builder.Services.AddHostedService<DataSyncService>();
```


## 13. 애플리케이션 보안

보안은 애플리케이션 개발의 중요한 측면입니다. 모범 사례를 무시하면 취약성, 데이터 침해 및 무단 액세스가 발생할 수 있습니다. 적절한 인증을 구현하고, 민감한 데이터를 보호하고, 보안 제어를 시행하는 것이 최우선 과제가 되어야 합니다.

#### **비밀을 하드코딩하지 마세요**

코드에서 API 키, 데이터베이스 자격 증명 또는 토큰을 하드코딩하는 것은 주요 보안 위험입니다. 대신 **보안 스토리지 솔루션을** 사용하십시오.

* **환경 변수** (로컬 개발용)
* **Azure Key Vault** 또는  **AWS Secrets Manager** (클라우드 기반 비밀 관리용)
* 로컬 개발을 위한 NET의 사용자 비밀(`dotnet user-secrets`)

#### **적절한 인증 및 권한 부여 구현**

* 인증에 **OAuth 2.0/OpenID Connect** 사용(예: IdentityServer, Keycloak, Azure AD)
* 보안 API 인증을 위해 **JWT(JSON 웹 토큰)** 사용
* **RBAC(역할 기반 액세스 제어)** 를 적용하여 사용자 작업 제한

CORS를 올바르게 구성

잘못된 CORS(Cross-Origin Resource Sharing)설정으로 인해  API가 승인되지 않는 요청에 노출될 수 있다.

나쁜예(너무 개방적)

```csharp
app.UseCors(builder => builder.AllowAnyOrigin().AllowAnyMethod().AllowAnyHeader());
```

더나은 방식(신뢰할 수 있는 도메인으로 제한)

```csharp
app.UseCors(builder => builder.WithOrigins("https://trustedsite.com")
    .AllowMethods("GET", "POST")
    .AllowHeaders("Content-Type"));
```
