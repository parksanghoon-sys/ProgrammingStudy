# REST 소개 및 중요성

## REST란?

네트워크 애플리케이션을 설계하기 위한 아키텍처 스타일이다, REST는 상태 비저장 클라이언트 - 서버 통신 프로토콜에 의존하며, 간단하고 확장이 용이하도록 설계되었다.

단순성과 유연성으로 널리 채택이 되었으며 XML에 의존하고 엄격한 구조를 가진 SOAP와 달리 REST는 표준 HTTP 메서들를 사용하며 JSON, XML 또는 HTML과 같은 다양한 형식으로 데이터를 반환이 가능하다, 이를 통해 RESTfull API를 더 쉽게 구현 및 사용이 가능하다

### .NET 개발자를 위한 RESTful API의 이점

* **확장성** : RESTful API는 상태 비저장이므로 각 요청은 독립적입니다. 따라서 확장성이 뛰어납니다.
* **단순성** : REST는 표준 HTTP 메서드(GET, POST, PUT, DELETE)와 간단한 URI를 사용하므로 이해하고 사용하기 쉽습니다.
* **유연성** : RESTful API는 클라이언트의 필요에 따라 JSON 또는 XML과 같은 다양한 형식으로 데이터를 반환할 수 있습니다.
* **관심사 분리** : REST는 클라이언트(프론트엔드)와 서버(백엔드)를 분리하여 둘 다 독립적으로 발전할 수 있도록 합니다

## REST 원칙에대한 심층 분석

**클라이언트 서버 아키텍쳐**

* 클라이언트는 사용자 인터페이스 및 사용자 경험을 담당
* 서버는 데이터 저장소, 비지니스 논리 및 리소스 관리를 처리한다.

**상태 비저장 시스템**

* 서버는 요청간에 클라이언트 컨텍스트를 저장하지 않는다.
* 클라이언트는 각 요청에는 요청을 처리하는데 필요한 모든 정보가 포함되어야 한다.
* 확장성 : 서버는 세션상태를 유지하지 않기 때문에 많은 수의 요청을 효율적으로 처리할
* 단순성 : 비저장 시스템은 각 요청이 독립적이기에 구현 및 디버깅이 유리

### 균일한 인터페이스

API의 일관성과 예층 가능성을 보장하여 개발자가 더 쉽게 이해하고 사용할 수 있도록 한다.

균일한 인터페이스는 4가지 제약조건을 통해 달성한다

1. 리소스기반 각 리소스는 고유한 URI 로식별
2. HTTP 메서드를 사용하여 리소스에 대한 작업을 수행
3. 표현 : 리소스에는 JSON, XML 또는 HTML과 같은 여러 표현이 있을 수 있다
4. 자체 설명 메시지 : RESTful API는 각 메시진는 처리방법을 설명하기에 충분한 정보가 포함

### 캐시가능

성능향상을 위해 캐싱을 지원, 

### 계층 시스템

REST를 사용시 클라이언트가 서버와 직접 통신하는지 아니면 중개자(프록시)를 통해 통신하는지 알 필요가 없는 계층화된 아키텍쳐를 사용

클라이언트는 RESTful API 요청을 보내며, 이 API는 로드벨런서를 통해 여러 백앤드 서버중 하나로 라우팅 된다, 클라이언트는 아키텍쳐를 인식하지 못한다

#### 계층화된 시스템의 이점:

* **확장성** : 클라이언트에 영향을 주지 않고 레이어를 추가하거나 제거할 수 있습니다.
* **보안** : 중개자는 SSL 종료와 같은 추가 보안을 제공할 수 있습니다.

---

## **.NET 개발자를 위한 RESTful API **

## **리소스 URI에 명사 사용**

URI는 작업이 아닌 리소스를 나타내야 합니다. 동사 대신 명사를 사용합니다.

#### 본보기:

* 좋다: `/api/users`
* 나쁘다: `/api/getUsers`

---

## **리소스 URI에 복수 명사 사용**

RESTful API를 디자인할 때 리소스 이름은 엔터티 컬렉션을 나타내기 위해 복수형이어야 합니다. 이렇게 하면 API가 일관되게 유지되고 REST 원칙에 부합합니다.

#### 본보기:

* **좋다:** `/api/users`
* **나쁘다:** `/api/user`

단일 엔터티를 다룰 때에도 복수형은 직관적으로 유지됩니다.

* **모든 사용자 가져오기:** `GET /api/users`
* **단일 사용자 가져오기:** `GET /api/users/{id}`

이 접근 방식은 명확성을 향상시키고 엔드포인트 간에 일관성을 유지합니다.

---

## **끝점에서 중첩을 사용하여 관계 표시**

리소스에 계층적 관계가 있는 경우 중첩된 경로를 사용하여 해당 구조를 반영합니다. 이렇게 하면 명확성이 향상되고 API가 더 직관적으로 만들어집니다.

#### 본보기:

* 좋음: (사용자에 대한 모든 주문 가져오기)`/api/users/{userId}/orders`
* **나쁘다:** `/api/orders?userId={userId}`

특정 엔터티의 경우:

* 좋음: (사용자에 대한 특정 주문 가져오기)`/api/users/{userId}/orders/{orderId}`
* **나쁘다:** `/api/orders/{orderId}`

자식 리소스가 부모에 크게 종속된 경우에만 중첩을 사용합니다. 독립적으로 존재할 수 있다면 평평한 구조가 바람직합니다.

---

## **경로 매개 변수와 쿼리 매개 변수를 사용하는 경우 파악**

경로 매개 변수와 쿼리 매개 변수 중에서 선택하는 것은 전달되는 데이터 유형과 요청의 의도에 따라 다릅니다.

#### **경로 매개변수** (리소스 식별용)

계층 구조에서 리소스 또는 엔터티를 지정할 때 경로 매개 변수를 사용합니다.

**본보기:**

* 좋음: (특정 사용자 가져오기)`/api/users/{userId}`
* **나쁘다:** `/api/users?userId={userId}`

#### **쿼리 매개 변수** (필터링, 정렬 및 페이지 매김용)

요청을 구체화하지만 리소스 ID를 변경하지 않는 선택적 매개 변수에 쿼리 매개 변수를 사용합니다.

**본보기:**

* **좋다:** `/api/users?role=admin&sort=asc&page=2`
* **나쁘다:** `/api/users/admin/sort/asc/page/2`

이 접근 방식을 따르면 API를 깨끗하고 예측 가능하며 사용하기 쉽게 유지할 수 있습니다.

---

## **캐싱을 사용하여 API 성능 향상**

캐싱은 자주 액세스하는 데이터를 저장하여 서버 부하와 응답 시간을 줄이는 데 도움이 됩니다. 적절한 캐싱 전략을 구현하면 API 성능을 크게 향상시킬 수 있습니다.

#### **REST API의 캐싱 유형:**

1. **클라이언트 측 캐싱**
   * 헤더를 사용하여 브라우저와 클라이언트가 응답을 캐시할 수 있도록 합니다.`Cache-Control``ETag`
   * **본보기:**
     ```
     Cache-Control: max-age=3600, publicETag: "abc123"
     ```
   * 클라이언트는 불필요한 데이터 전송을 방지하기 위해 ETag와 함께 사용할 수 있습니다.`If-None-Match`
2. **서버 측 캐싱**
   * 자주 액세스하는 응답을 메모리에 저장합니다(예: Redis, 메모리 내 캐싱).
   * 반복되는 데이터베이스 쿼리를 줄이는 데 이상적입니다.
   * [InMemory 캐싱](https://codewithmukesh.com/blog/in-memory-caching-in-aspnet-core/), [분산 캐싱](https://codewithmukesh.com/blog/distributed-caching-in-aspnet-core-with-redis/) 및 [응답 캐싱](https://codewithmukesh.com/blog/caching-with-mediatr-in-aspnet-core/)에 대해 알아보십시오.
3. **CDN 캐싱**
   * CDN(Content Delivery Networks)을 사용하여 더 빠른 액세스를 위해 사용자에게 더 가까운 정적 응답을 캐시합니다.
   * 트래픽이 많은 대규모 API에 적합합니다.
4. **데이터베이스 쿼리 캐싱**
   * 비용이 많이 드는 데이터베이스 쿼리의 결과를 캐시하여 성능을 향상시킵니다.
   * 데이터 최신성을 보장하기 위해 캐시 무효화 전략에 유의하십시오.

캐싱을 올바르게 구현하면 API의 확장성과 응답성을 크게 향상시킬 수 있습니다.

---

## **RESTful API에서 HTTP 메서드를 올바르게 사용**

RESTful API를 설계할 때 올바른 HTTP 방법을 선택하는 것은 명확성, 유지 관리 가능성 및 REST 원칙 준수를 위해 중요합니다. 일반적으로 사용되는 방법은 다음과 같습니다.

#### **1. GET(리소스 검색)**

* 서버에서 데이터를 가져오는 데 사용됩니다.
* **멱등성**이어야 하며, 이는 여러 요청이 데이터를 수정하지 않고 동일한 결과를 반환해야 함을 의미합니다.
* 본보기:
  ```
  GET /api/users       → Retrieves a list of usersGET /api/users/1     → Retrieves details of a specific user (ID = 1)
  ```

---

#### **2. POST(새 리소스 생성)**

* 서버에 새 리소스를 만드는 데 사용됩니다.
* **멱등성이 아님** – 동일한 요청을 여러 번 보내면 여러 리소스가 생성됩니다.
* 새 리소스를 가리키는 헤더와 함께 성공 시 반환됩니다.`201 Created``Location`
* 본보기:

  ```
  POST /api/usersBody:{ "name": "John Doe" }
  ```

  응답:

  ```
  201 CreatedLocation: /api/users/3
  ```

---

#### **3. PUT(기존 리소스 업데이트 - 전체 교체)**

* **전체 리소스를** 새 데이터로 대체하여 업데이트하는 데 사용됩니다.
* **멱등성** – 동일한 요청을 여러 번 보내면 서버에서 동일한 상태가 되어야 합니다.
* 리소스가 존재하지 않는 경우 일부 구현은 새 리소스( 동작)를 만듭니다.`Upsert`
* 본보기:

  ```
  PUT /api/users/1Body:{ "id": 1, "name": "John Smith" }
  ```

  * 있는 경우 전체 사용자 개체를 새 데이터로 바꿉니다.`id=1`
  * 존재하지 않는 경우 일부 API는 새 사용자를 만들 수 있습니다.`id=1`

---

#### **4. PATCH(부분 업데이트 - 특정 필드 수정)**

* 전체 개체를 바꾸는 대신 리소스의 **특정 필드만** 업데이트하는 데 사용됩니다.
* 반**드시 멱등성은 아닙니다** – 구현에 따라 동일한 요청을 여러 번 보내면 다른 효과가 있을 수 있습니다.
* 본보기:

  ```
  PATCH /api/users/1Body:{ "name": "John Smith" }
  ```

  이렇게 하면 다른 속성을 수정하지 않고 사용자의 필드만 업데이트됩니다.`name`

---

#### **5. DELETE(리소스 제거)**

* 서버에서 리소스를 삭제하는 데 사용됩니다.
* 멱등성이어야 함 – 리소스가 이미 삭제된 경우 후속 DELETE 요청은 또는 .`204 No Content``404 Not Found`
* 본보기:

  ```
  DELETE /api/users/1
  ```

  응답:

  ```
  204 No Content
  ```

---

## **PUT 대 PATCH – 차이점은 무엇입니까?**

둘 다 리소스를 업데이트하는 데 사용되지만 서로 다른 용도로 사용됩니다.`PUT``PATCH`

| 특징                | PUT(전체 업데이트)                                            | PATCH(부분 업데이트)                                                                 |
| ------------------- | ------------------------------------------------------------- | ------------------------------------------------------------------------------------ |
| **목적**      | 전체 리소스를 대체합니다.                                     | 자원의 특정 필드를 수정합니다.                                                       |
| **요청 본문** | 변경되지 않은 필드를 포함하여 전체 개체를 포함해야 합니다.    | 업데이트해야 하는 필드만 포함합니다.                                                 |
| **멱등성?**   | 예, 여러 개의 동일한 요청으로 인해 동일한 최종 상태가 됩니다. | 반복되는 PATCH 요청으로 리소스가 다르게 변경될 수 있으므로 반드시 그런 것은 아닙니다 |
| **사용 사례** | 모든 필드가 업데이트되었는지 확인하려는 경우                  | 몇 개의 필드만 변경해야 하는 경우                                                    |
| **예제 요청** | `{ "id": 1, "name": "John Smith", "age": 30 }`              | `{ "name": "John Smith" }`                                                         |

### **어느 것을 사용해야 할까요?**

* 리소스의 **모든 필드**를 업데이트할 때 **PUT**을 사용하여 일관성을 보장합니다.
* 불필요한 업데이트를 방지하기 위해 **특정 필드만 수정할** 때 **PATCH**를 사용합니다.

---

## **HTTP 상태 코드 사용**

요청 결과를 나타내는 적절한 HTTP 상태 코드를 반환합니다.

* `200 OK`:성공.
* `201 Created`: 리소스가 성공적으로 생성되었습니다.
* `400 Bad Request`: 잘못된 입력입니다.
* `404 Not Found`: 리소스를 찾을 수 없습니다.
* `500 Internal Server Error`: 서버 오류입니다.

#### 본보기:

```
returnNotFound(); // Returns 404returnOk(user);  // Returns 200
```

---

## **API 버전 관리**

기존 클라이언트에 대한 호환성이 손상되지 않도록 항상 API의 버전을 지정합니다.

#### 본보기:

* `/api/v1/users`
* `/api/v2/users`

---

## **데이터 교환에 JSON 사용**

JSON은 REST API에 가장 널리 사용되는 형식입니다. 가볍고 구문 분석하기 쉽습니다.

#### 본보기:

```
{"id": 1,"name": "John Doe"}
```

NET에서는 네임스페이스를 사용하여 JSON을 직렬화 및 역직렬화할 수 있습니다.`System.Text.Json`

---

## **페이지 매김, 필터링 및 정렬 구현**

리소스 목록을 반환하는 엔드포인트의 경우 페이지 매김, 필터링 및 정렬을 지원하여 성능과 유용성을 개선합니다.

#### 본보기:

```
GET /api/users?page=1&pageSize=10&sortBy=name
```

---

## **API 보안**

* HTTPS를 사용하여 전송 중인 데이터를 암호화합니다.
* 인증 및 권한 부여(예: JWT 토큰, OAuth)를 구현합니다.

---

## **API 문서화**

API에 대한 명확하고 포괄적인 문서를 제공합니다. Swagger(OpenAPI)와 같은 도구는 이 프로세스를 자동화하는 데 도움이 될 수 있습니다.


# 결론

REST는 간단하고 확장 가능하며, 사용하기 쉬운 웹 API를 구축하기 위한 강력한 아키텍쳐 스타일이다,
