[[00.디자인 패턴]]

프로토 타입 패턴은 처음부터 만들지 않고 기존 개체를 복사해서 새 개체를 만드는 생성 디자인 패턴이다, 즉 생성자를 이용해 새로운 객체를 생성하는 대신 개존객체(프로토 타입)를 복사해 새 객체를 만들어 개체 생성 비용이나 시간을 줄일 수 있다. 복제된 오브젝트는 원본에 영향을 주지 않고 그 필요에 따라 수정이 가능하다.

### 작동원리
기본적으로 프로토타입 패턴에는 자신을 복제하는 방법을 알고 있는 **프로토타입 개체가** 필요하다 인터페이스를 이용해 상속받는 클래스의 clone 등의 메서드를 이용해 복사를 할수 있도록 한다.
클라이언트 코드는 이니셜라이저를 직접 사용하는 대신 프로토타입 인스턴스를 호출하기만 하면 됩니다
내부적으로 호출**은 개체 생성을 개체 자체에 위임합니다**. 이는 개체가 개인 필드 복사를 포함하여 복사본을 만드는 세부 사항을 처리한다는 것을 의미하며, 이는 외부에서는 불가능합니다,체가 스스로를 복제하도록 함으로써 **외부 코드가 객체의 구체적인 클래스에 묶이는 것을 피할 수 있습니다**.
### 프로토타입을 사용하는 경우(vs. 처음부터 구성)

- **복잡하거나 비용이 많이 드는 개체 생성:** 개체를 처음부터 만드는 데 비용이 많이 드는 경우(예: 비용이 많이 드는 계산, I/O 작업 또는 많은 구성이 포함됨) 미리 초기화된 기존 개체를 복제하는 것이 훨씬 더 빠를 수 있습니다. 비용이 많이 드는 설정을 한 번 수행한 다음 필요에 따라 결과를 복제합니다.
- **다양한 구성 옵션:** 객체에 무수히 많은 구성 가능한 속성 (다양한 조합을 가진 수십 개의 필드)이 있으면 모든 순열을 포괄하는 수많은 하위 클래스 또는 생성자 매개 변수로 끝날 수 있습니다. 프로토타입은 다음과 같은 대안을 제공합니다: 몇 가지 일반적인 방식으로 구성된 몇 가지 기본 프로토타입을 만든 다음 필요에 따라 복제하고 조정합니다. 이렇게 하면 하위 클래스 폭발 및 긴 매개 변수 목록을 피할 수 있습니다. 기본적으로 **몇 가지 프로토타입을 미리 빌드하고 복제를 통해 재사용합니다**.
- **런타임에 알 수 없는 구체적인 유형:** 코드가 인터페이스 또는 추상 기본 클래스로 작업 중이고 인스턴스화 할 정확한 구체적인 클래스를 모르는 경우 생성자가 도움이되지 않습니다 (어떤 하위 클래스를 모르는 경우 직접 수행 할 수 없습니다). 그러나 손에 물건이 있고 (아마도 당신에게 제공되었을 수도 있음) 그와 같은 다른 물건이 필요한 경우 프로토 타입이 이상적입니다. 알려진 인터페이스 메서드(clone)를 호출하고 개체가 복제되도록 합니다. 이렇게 하면 코드에서 **구체적인 클래스에 묶이지 않고 새 개체를 만들** 수 있습니다
- **생성자 오염 방지:** 경우에 따라 클래스에는 서로 다른 초기화 구성을 허용하는 여러 생성자 또는 빌더 단계가 있을 수 있습니다. clone을 사용하면 클라이언트에 대한 객체 생성을 단순화할 수 있습니다: 기본 객체를 만든 다음 다른 생성자를 호출하는 대신 복제합니다. 프로토타입은 이미 특정 상태를 구현하고 있으므로 빠르게 복사할 수 있습니다.
- **런타임에 타입 추가하기:** 플러그인 또는 런타임 확장을 허용하는 시스템에서는 런타임에 새 개체 프로토타입을 등록하도록 허용할 수 있습니다. 프로토타입 패턴을 사용하는 코드는 다시 컴파일할 필요 없이 이러한 새 프로토타입을 복제할 수 있습니다. **런타임에 프로토타입 인스턴스를 추가하거나 제거하는** 이 기능은 시스템을 보다 유연하게 만듭니다.

### 장점
1. 비용이 많이드는 초기화를 방지한다
2. 서브 클래싱 및 복잡성 감소
3. 생산 복잡성을 숨긴다
4. 구체적인 클레스에서 코드를 분리
5. 복사 및 조정
6. 다니나믹 런타임에 작동이 가능하다.

요약하면 Prototype은 개체 생성에 **유연성과 효율성을** 제공합니다. 그것은 당신이 **빠르게(복사를 통해) 그리고 추상적으로(클래스 특정을 필요로 하지 않고)** 새로운 객체를 만들 수 있게 해줍니다.

### 단점 및 완화 방법
 * Clone 메서드 구현
	 * 복제 가능하려는 모든 클래스는 복제 논리를 구현해야 합니다
	 * 완화 방법
		 * base 클래스가 공통으로 필드를 복사하도록 처리
* 얕은 복사 vs 깊은 복사의 복잡도
* 복제본이 리소스를 가질 경우 해당 리소스의 처리
* 복잡한 합성 개체는 복제가 어려울수 있다.
### 결론
프로토타입 디자인 패턴은 개체를 직접 구성하는 것이 비실용적이거나 비효율적인 경우 개체를 만들 수 있는 대체 방법을 제공한다
