# 멀티쓰레드와 비동기 IO에 대해

멀티스레딩 프로그램을 나누면 Computed-Bounded Thread 와 IO-Bounded Thread로 나뉠 수 있다.

### Computed Thread

CPU, CPU Cache, 메인 메모리 범위에서 수행되는 작업이다.

보통의 수학 연산이나, 메모리상의 Data 처리에 해당된다, 알고리즘이나 IO 작업이 아닌 시간을 동작하는데 시간이 소요되는 비지니스 로직을 처리하는 부분이다

### IO Thread

CPU, 메모리를 제외한 HDD, 네트웍과 같은 외부저장장치와의 통신 작업, API 조회, DB 작업등의 통신 작업 등을 수행하는 스레드 이다.

예를들면 파일 내용을 읽어오는 작업을 스레드로 만든다면, 백그라운드 스레드에서 돌게하며, 메인스레드는 다른 작업을 수행 할 수있도록 효과적인 프로그램을 만들 수 있다.

### 비동기 IO 작업

1. 백그라운드 스레드 생성
2. 비동기 IO 명령을 통해 읽기 요청
   1. 비동기 결과를 받는 토큰 방식(APM)
   2. 완료이벤트를 받는 방식(EAP)
3. IO 스레드가 죽음
4. 완료되었음을 통지받음 (토큰 또는 이벤트)
5. 새로운 스레드가 생성
6. 실제 Data 읽기
7. 스레드 종료

여기서 비동기 IO 방식이 IO-Bounded 멀티스레드와 다른점은 전체 작업이 이루어질동안 스레드가 살아있느냐. 실제 작업 시에만 스레드가 살아 있느냐의 차이 이다

Thread Context Switching 부하 문제 때문이다, Thread를 여러개 만드는 것보다 ThreadPool 과 Workder Thread를 사용하는 것이 더 효과적인것은 이미 알려졋는데 이 방식은 Thread ContextSwitching 부하를 최대한으로 감소하게 하는 기능이다.

위의 3 ~ 4 ㄷ오안이 1~ 6중 미미한 시간을 차지할 수도 있고, 대부분의 시간을 차지할 수 있다, HDD가 아닌 Network를 통한 DB의 정보를 가져오는 예라면 3 ~ 4구간은 대부분을 차지한다, 이 말은 대부분의 작업의 스레드를 살려놔서, OS로 하여금 Thread Context Switching 부하가 발생시기게 된다, 이렇게 노는 스레드가 많아진다면, 시스템이 느려지고, 작업처리 속도 또한 느려지니, 멀티스레드 프로그래밍은 복잡하고, 성능이 나오지 않는다고 생각될수 있다.

싱글 스레드를 가진 노드는 I/O 작업이 시작되면 I/O 작업처리에 대한 응답을 기다리지 않고, 바로 다음 작업을 실행한다, 대신 I/O 작업이 종료되면 이벤트르 발생시키고, 이 이벤트는 해당 프로세스의 이벤트 큐에 등록되게 된다. 노드로 개발된 프로세스는 이 이벤트 큐에 등록된 새로운 이벤트를 감지하며, 해당 이벤트 시 수행해야할 작업을 실행하게 된다.

이벤트 루프라는것은 작업을 요청하면서 그 작업이 완료되었을 때 어떤 작업을 진행할지에 대한 콜백 함수를 지정하여 동작이 완료되었을때 해당 콜백 함수를 실행되는 동작 방식을 말한다

만약 클라이언트가 웹서버에 HTTP 형식으로 요청 시 서버는 이벤트루프가 계속 돌고 있다가 이를 감지하고 알맞은 작업을 워커 쓰레드를 생서하여 실행한다, 이때 이벤트 루프는 해당 워커 스레다가 작업을 마친 뒤 그 결과와 함께 응답할 때까지 기다리는것이 아니라 바로 루프에 복귀하여 다른 요청을 기다리게 된다.

>  이벤트 루프는 어떤 요청이 발생 시 해당 작업에 대한 스레드 실행을 진행할 뿐이다. 이후 작업을 할당 받았던 스레드가 모든 작업을 마친다면 미리 전달받은 콜백 함수를 실행하도록, 이벤트 루프가 응답하게 되며, 이벤트 루프는 이것을 실행하여 클라이언트에게 결과를 응답해준다.
